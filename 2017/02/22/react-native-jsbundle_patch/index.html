<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React Native拆包及热更新方案 · Solartisan</title><meta name="description" content="React Native拆包及热更新方案 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Native拆包及热更新方案</h1><div class="post-info">Feb 22, 2017</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">solart</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p>随着 <code>React Native</code> 的不断发展完善，越来越多的公司选择使用 <code>React Native</code> 替代 <code>iOS/Android</code> 进行部分业务线的开发，也有不少使用 <code>Hybrid</code> 技术的公司转向了 <code>React Native</code> 。要说 <code>React Native</code> 最能吸引开发者的地方那就是其拥有前端的开发速度以及原生的体验。</p>
<h2 id="1、序言"><a href="#1、序言" class="headerlink" title="1、序言"></a>1、序言</h2><p>今天要跟大家探讨的是 <code>React Native</code> 的拆包及热更新方案，官方并没有很好的支持这一企业十分看中的热更新能力，因此也催生了第三方的热更新方案，如 <a href="https://microsoft.github.io/code-push/docs/react-native.html" target="_blank" rel="external">CodePush</a> 、 <a href="https://github.com/reactnativecn/react-native-pushy" target="_blank" rel="external">react-native-pushy</a> 。由于公司内部有不同的业务线，所以在采用第三方的热更新方案灵活度不够，在调研的初期，我们参考了携程的提到的 <code>jsbundle</code> <a href="https://zhuanlan.zhihu.com/p/23715716" target="_blank" rel="external">拆分和加载优化方案</a>，但这个方案需要改变 <code>React Native</code> 的打包代码及 <code>Runtime</code> 代码，实施难度上非常大，暂无精力深入研究，但这个方案对加载速度提升也是显而易见的。我们暂时放弃了携程的方案，我们前期需要一套相对简单稳定且可行度高的方案，在经过调研及讨论后定下了这样一套热更方案，今天我们就来聊聊这个方案。</p>
<a id="more"></a>
<h2 id="2、流程梳理"><a href="#2、流程梳理" class="headerlink" title="2、流程梳理"></a>2、流程梳理</h2><p>由于存在多条业务线开发，又希望业务线之间互相独立，但是全量的 bundle 文件又过于庞大，基于这样的考量，我们决定采用业务代码独立热更的方案。</p>
<p>整体流程其实非常简单，不过内部一些细节规则需要仔细推敲。</p>
<p><img src="/images/rn_update_process.png" alt="rn-update-process"></p>
<h2 id="3、热更新模块的实现方案"><a href="#3、热更新模块的实现方案" class="headerlink" title="3、热更新模块的实现方案"></a>3、热更新模块的实现方案</h2><p>当下选择使用 <code>React Native</code> 的项目大都是基于原有项目的基础上进行接入，所以要达到上线的项目的状态自然要各方面都准备就绪，热更新就作为基建工程之一。以下主要以 Android 端为例进行阐述，iOS 端方案基本一致。</p>
<h4 id="2-1-jsbundle-的拆分"><a href="#2-1-jsbundle-的拆分" class="headerlink" title="2.1 jsbundle 的拆分"></a>2.1 jsbundle 的拆分</h4><p>对 <code>React Native</code> 的代码打包编译后会生成一个 <code>bundle</code> 文件，这里要说明一下，<code>jsbundle</code> 的拆分是基于生成的 <code>bundle</code> 文件可以看成两部分构成（如下图）：一是 <code>React Native</code> 包含的的基础类库，一是开发的业务代码。</p>
<p><img src="/images/jsbundle.png" alt="jsbundle"></p>
<p>基于 bundle 文件的这一特点，我们就可以将完整的 <code>bundle</code> 文件拆分为两部分：</p>
<p>首先需要做的就是生成 <code>common.bundle</code> ，新建一个 <code>blank.js</code> 文件，在文件中仅引入 <code>react</code> 及 <code>react native</code> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br></pre></td></tr></table></figure>
<p>通过打包命令编译成 <code>common.bundle</code>  :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --entry-file blank.js --bundle-output ~/Desktop/common.bundle --platform android --dev false</span><br></pre></td></tr></table></figure>
<p>其次，打包完整的 <code>jsbundle</code> ，这将会包含所有的基础类库及业务代码。提醒一句保持 import 的公共模块一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="comment">//其他导入</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后根据 diff 算法将两个文件进行 diff 拆分，由此会生成一个 <code>*.diff</code> 的二进制文件，例如 <code>index.diff</code> 。</p>
<p><img src="/images/indexdiff.png" alt="diff"></p>
<p>到这里，大家会得到一个 <code>common.bundle</code> 的文件，一个或多个 <code>*.diff</code> 文件。</p>
<blockquote>
<p>关于 diff 算法的使用，记得有几篇文章中推荐 <a href="https://code.google.com/p/google-diff-match-patch/" target="_blank" rel="external">google-diff-match-patch</a> ，虽然 Google 这个开源版本包含多种语言的实现，但由于是基于纯文本的 diff 所以在当下这个场景下并不十分合适，我还是推荐大家使用基于二进制的 diff ，在此也推荐另一种 java 版本的 bsdiff 的实现：<a href="https://github.com/jdesbonnet/jbdiff" target="_blank" rel="external">jbdiff</a> 。</p>
</blockquote>
<h4 id="2-2-bundle-文件的拷贝及合成"><a href="#2-2-bundle-文件的拷贝及合成" class="headerlink" title="2.2 bundle 文件的拷贝及合成"></a>2.2 bundle 文件的拷贝及合成</h4><p>在完成拆分以后，我们需要将 <code>common.bundle</code> 及拆分的 <code>*.diff</code> 文件进行 <code>zip</code> 压缩，放入 <code>assets</code> 目录下，为了方便版本管理，我们将其文件名中写入版本号 <code>jsbundle_&lt;版本号&gt;.zip</code> ，例如：<code>jsbundle_1.zip</code> ，每次改 zip 文件包跟随发版时更新，并自动升级版本号。</p>
<p>接下来我们要做的就是将内置于 <code>assets</code> 目录下的 <code>jsbundle_*.zip</code> 拷贝至内部存储，这里不推荐使用外部存储，尽量避免用户删除这些文件。</p>
<p>在拷贝过程中根据历史记录的版本号，进行判断是否需要执行拷贝，拷贝完成后将 <code>common.bundle</code> 及<code>*.diff</code> 文件进行 <code>patch</code> 合并，合并后的文件即为一个完整的 bundle 文件，文件名规定为 <code>*.diff.bundle</code> ，例如：<code>index.diff.bundle</code> ，在加载时根据模块名进行加载即可。</p>
<h4 id="2-3-diff-文件的更新"><a href="#2-3-diff-文件的更新" class="headerlink" title="2.3 diff 文件的更新"></a>2.3 diff 文件的更新</h4><p>说到热更新，反而在关于 <code>*.diff</code> 文件的更新本身并没有什么复杂度，简单来说就是下载替换 <code>*.diff</code> 文件，并合成新的完整 <code>bundle</code> 文件，其他需要注意的则是关于 <code>diff</code> 文件版本的控制。</p>
<p>其他主要工作量在于 diff 文件的生成及上传，这部分工作量最好是不依赖于人工，可以考虑编写 shell 脚本自动完成，以下摘录部分 packer.sh 的打包代码供参考。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $platform == &#34;android&#34; ]; then&#10;&#9;react-native bundle \&#10;        --entry-file $commonFile.js \&#10;        --bundle-output $androidModuleDir/common.bundle \&#10;        --platform android \&#10;        --dev false&#10;&#10;    echo &#34;common.bundle packed!!!&#34;&#10;&#10;    react-native bundle \&#10;        --entry-file $module.js \&#10;        --bundle-output $androidModuleDir/$module.android.bundle \&#10;        --platform android \&#10;        --dev false&#10;&#10;    echo &#34;$module.android.bundle packed!!!&#34;&#10;&#10;    # &#23545; jbdiff &#25171;&#25104;&#30340; jar &#25191;&#34892;&#25991;&#20214;&#10;    chmod +x dmp.jar &#10;&#10;    echo &#34;diff start =========&#62;&#62;&#62;&#34;&#10;    java -jar ./dmp.jar $androidModuleDir/common.bundle \&#10;        $androidModuleDir/$module.android.bundle $androidModuleDir/$module.diff&#10;    # &#36827;&#34892;&#20108;&#27425; zip &#21387;&#32553;&#10;    zip -j $androidModuleDir/$module.diff.zip $androidModuleDir/$module.diff&#10;elfi ...</span><br></pre></td></tr></table></figure>
<h4 id="2-4-对于容器-Activity-的改造"><a href="#2-4-对于容器-Activity-的改造" class="headerlink" title="2.4 对于容器 Activity 的改造"></a>2.4 对于容器 Activity 的改造</h4><p>由于对于 <code>React Native</code> 的 bundle 文件加载做了更改，我们就不能直接使用 sdk 提供的 <code>ReactActivity</code> 了，对此我们需要对容器 Activity 进行改造。</p>
<p>而改造的最终落脚点其实是 <code>ReactInstanceManager</code> 的构建，由于我们需要按业务模块加载，所以最终将其进行了部分改造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactNativeHost</span> <span class="keyword">extends</span> <span class="title">ReactNativeHost</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MyReactNativeHost</span><span class="params">(Application application, String moduleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(application);</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mModuleName = moduleName;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ReactInstanceManager <span class="title">createReactInstanceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getUseDeveloperSupport())&#123; <span class="comment">//为了保留 debug 的能力</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.createReactInstanceManager();</span><br><span class="line">        &#125;</span><br><span class="line">        String path = JSBundleManager.getJSBundleDirPath(mApplication)</span><br><span class="line">                .concat(mModuleName).concat(<span class="string">".diff.bundle"</span>);</span><br><span class="line">        ReactInstanceManager.Builder builder = ReactInstanceManager.builder()</span><br><span class="line">                .setApplication(mApplication)</span><br><span class="line">                .setJSBundleLoader(JSBundleLoader.createFileLoader(path))</span><br><span class="line">                ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将改造后的 Activity 容器也要接入原有项目的路由框架（如果项目本身有的话），至此，整个更新加载就可以串起来了。由于 <code>React Native</code> 本身没有提供 <code>reload</code> 机制，如果需要在更新 bundle 文件后强制刷新页面，需要通过反射处理 <code>ReactInstanceManagerImpl::recreateReactContextInBackgroundFromBundleLoader</code> 达到重新加载刷新页面的效果，比较简单，这里就不再赘述。</p>
<h2 id="4、热更新改造的后遗症"><a href="#4、热更新改造的后遗症" class="headerlink" title="4、热更新改造的后遗症"></a>4、热更新改造的后遗症</h2><p>由于采用加载文件系统下的 <code>bundle</code> 文件的形式，在测试过程中发现通过此形式加载的 <code>bundle</code> 文件，图片加载时不能读取到 <code>res</code> 目录下的资源文件，带着这个问题看了相关的 js 源码，发现了一个有意思的地方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssetSourceResolver</span> </span>&#123;</span><br><span class="line">  isLoadedFromFileSystem(): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>.bundlePath;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defaultAsset(): ResolvedAssetSource &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isLoadedFromServer()) &#123; <span class="comment">//如果是从服务器下发的bundle，资源从服务器读取，对应debug模式</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.assetServerURL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123; <span class="comment">//在android平台</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.isLoadedFromFileSystem() ?</span><br><span class="line">        <span class="keyword">this</span>.drawableFolderInBundle() :<span class="comment">//如果是从文件系统读取的bundle则从文件系统取资源</span></span><br><span class="line">        <span class="keyword">this</span>.resourceIdentifierWithoutScale();<span class="comment">//否则从res读取资源</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.scaledAssetPathInBundle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  resourceIdentifierWithoutScale(): ResolvedAssetSource &#123;</span><br><span class="line">    invariant(Platform.OS === <span class="string">'android'</span>, <span class="string">'resource identifiers work on Android'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fromSource(assetPathUtils.getAndroidResourceIdentifier(<span class="keyword">this</span>.asset));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  drawableFolderInBundle(): ResolvedAssetSource &#123;</span><br><span class="line">    <span class="keyword">const</span> path = <span class="keyword">this</span>.bundlePath || <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fromSource(</span><br><span class="line">      <span class="string">'file://'</span> + path + getAssetPathInDrawableFolder(<span class="keyword">this</span>.asset)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里就明白了，源码中对资源的加载保持了跟 bundle 文件同源。要解决这个问题有两个方案：1、将 js 源码中的逻辑进行修改，都从 res 中读取资源；2、将 <code>React Native</code> 使用到的资源打包到本地，跟随 jsbundle_*.zip 发布。我个人比较倾向于第二个方案，我主要考虑两点：一是后续 <code>React Native</code> 版本升级的成本，一是可以对于 <code>React Native</code> 的资源单独管理，同时也意外的获得了一个 <code>React Native</code> 资源热更的能力。</p>
<p>整个更新方案到这里基本阐述完毕，方案简单且可行度高，唯一的遗憾是在加载速度上并没有什么提升。我个人感觉 <code>React Native</code> 在 Android 端的加载速度还是个硬伤，机型众多，性能差异极大，在 <code>iOS</code> 端的表现就好上很多 。</p>
<p>最后，吐槽下 <code>React Native</code> 的一个坑，目前最新的 <code>0.41.0</code> 版的 <code>Android</code>  端通过<code>&lt;Image /&gt;</code> 的 <code>loadingIndicatorSource</code> 属性来指定占位图依然无效，15 年的一个 issues <a href="https://github.com/facebook/react-native/issues/5017" target="_blank" rel="external">#5017</a> 到现在没有被修复，实在匪夷所思，感觉我是用了假的 RN !!</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/01/23/react-native-custom-view/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div data-thread-key="2017/02/22/react-native-jsbundle_patch/" data-title="React Native拆包及热更新方案" data-url="http://solart.cc/2017/02/22/react-native-jsbundle_patch/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"solart"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>