<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React Native渲染流程浅析 · Solartisan</title><meta name="description" content="React Native渲染流程浅析 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Native渲染流程浅析</h1><div class="post-info">Aug 20, 2017</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">solart</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p>随着跨平台技术的发展演进，<code>React Native</code> 被越来越多的公司所接受，因此在这里分享一下 <code>React Native</code> 渲染流程，希望能帮助大家对 <code>React Native</code> 进行更深入的理解。</p>
<h2 id="1、跨平台框架"><a href="#1、跨平台框架" class="headerlink" title="1、跨平台框架"></a>1、跨平台框架</h2><p>跨平台一直以来是一个工程实践上的真实需求，用来节约项目开发的人力成本、时间成本等，尤其是在当下移动互联网的时代。在 <code>React Native</code> 诞生之前，已经存在了很多跨平台的方案，例如：<code>Phone Gap</code> 、<code>Xamarin</code> 、<code>Corona</code> 等。</p>
<h4 id="1-1-跨平台框架都是伪命题？"><a href="#1-1-跨平台框架都是伪命题？" class="headerlink" title="1.1 跨平台框架都是伪命题？"></a>1.1 跨平台框架都是伪命题？</h4><ul>
<li><a href="http://phonegap.com/" target="_blank" rel="external">PhoneGap</a> 利用 open-web 技术，即 HTML 5、CSS3 以及 JavaScript 构建移动 Web 应用。</li>
<li><a href="https://www.xamarin.com/" target="_blank" rel="external">Xamarin</a> 利用 C# 语言开发原生移动应用，打包时将 C# 转化为对应平台的原生代码。</li>
<li><a href="https://coronalabs.com/" target="_blank" rel="external">Corona</a> 2D 游戏与应用开发平台，利用 lua 进行开发，主要面向游戏开发。</li>
</ul>
<p>在以上我们提到这个几个跨平台框架，相对来说是被采用较多或比较知名的，但也缺点十分明显。其实在接触 <code>React Native</code> 之前我一直都认为所谓跨平台框架都是伪命题，但是在接触之后，确实改变了我的认识。</p>
<h4 id="1-2-基于-JS-的跨平台框架"><a href="#1-2-基于-JS-的跨平台框架" class="headerlink" title="1.2 基于 JS 的跨平台框架"></a>1.2 基于 JS 的跨平台框架</h4><p><code>Facebook</code>在 <code>React.js Conf 2015</code> 大会上推出了基于 <code>JavaScript</code> 的开源框架 <code>React Native</code>。</p>
<p><code>React Native</code> 结合了 <code>Web</code> 应用和 <code>Native</code> 应用的优势，可以使用 <code>JavaScript</code> 来开发 <code>iOS</code> 和 <code>Android</code> 原生应用。在 <code>JavaScript</code> 中用 <code>React</code> 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染。这种方案与类似 <code>PhoneGap</code> 这种依赖 open-web 技术方案最大的不同就是 <code>React Native</code> 会将标签元素渲染成原生 UI 组件，从而提升性能及交互体验，使得应用本身更加接近原生应用的体验，也因此有越来越多的公司开始考虑 <code>React Native</code> 的跨平台方案。</p>
<a id="more"></a>
<h2 id="2、启动流程简介"><a href="#2、启动流程简介" class="headerlink" title="2、启动流程简介"></a>2、启动流程简介</h2><p>这一节并非是本文重点，是为了下面分析渲染流程进行一些铺垫。</p>
<h4 id="2-1-JS-是如何在-Android-上跑起来的？"><a href="#2-1-JS-是如何在-Android-上跑起来的？" class="headerlink" title="2.1  JS 是如何在 Android 上跑起来的？"></a>2.1  JS 是如何在 Android 上跑起来的？</h4><p>简单来说，就是通过 Native 发起创建 JS 运行环境，加载 <code>JS bundle</code> 后会执行 <code>AppRegistry::runApplication</code>，引导挂载根组件从而渲染出整个 UI ，具体流程可以参见下图。</p>
<p><img src="/images/rn_star_up_seq.png" alt="rn_star_up_seq"></p>
<h2 id="3、JS-端渲染分析"><a href="#3、JS-端渲染分析" class="headerlink" title="3、JS 端渲染分析"></a>3、JS 端渲染分析</h2><p>接下来，是本文的重点部分了，从门将先来分析 JS 端的渲染流程是怎样的。</p>
<h4 id="3-1-JSX-的转码"><a href="#3-1-JSX-的转码" class="headerlink" title="3.1 JSX 的转码"></a>3.1 JSX 的转码</h4><p>JSX 语法是对 JS语法的一种扩展，为了方便开发者在 JS 中编写 UI，在运行期间会通过 BABEL 转码，我们通过一个比较简单的示例来做转码，原始的 <code>React</code> 代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default class App extends Component &#123;&#10;  render() &#123;&#10;    return (&#10;      &#60;View style=&#123;styles.container&#125;&#62;&#10;        &#60;Text style=&#123;styles.welcome&#125;&#62;&#10;          Welcome to React Native!&#10;        &#60;/Text&#62;&#10;      &#60;/View&#62;&#10;    );&#10;  &#125;&#10;&#125;&#10;&#10;AppRegistry.registerComponent(&#39;App&#39;, () =&#62; App);</span><br></pre></td></tr></table></figure>
<p>转码后：（经过部分精简，大家也可以通过 <a href="http://babeljs.io/repl/" target="_blank" rel="external">BABEL</a> 在线转码以上示例）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> _react2 = _interopRequireDefault(_react);</span><br><span class="line"><span class="keyword">var</span> _reactNative = <span class="built_in">require</span>(<span class="string">'react-native'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123;<span class="keyword">default</span>: obj&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">App = <span class="function"><span class="keyword">function</span> (<span class="params">_Component</span>) </span>&#123;</span><br><span class="line">  _createClass(App, [&#123;</span><br><span class="line">    key: <span class="string">'render'</span>, value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        _react2.default.createElement(_reactNative.View, &#123;style: styles.container&#125;,</span><br><span class="line">          _react2.default.createElement(_reactNative.Text, &#123;style: styles.welcome&#125;, <span class="string">'Welcome to React Native!'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line">  <span class="keyword">return</span> App;</span><br><span class="line">&#125;(_react.Component);</span><br><span class="line">_reactNative.AppRegistry.registerComponent(<span class="string">'App'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> App;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到，原先 JSX 的元素都被 <a href="https://facebook.github.io/react/docs/react-api.html#createelement" target="_blank" rel="external">React.createElement</a> 转化为 <code>ReactElement</code>。在 <code>ReactElement</code> 中使用 type字段存放原始对象（在此处就是<code>ReactNative.View</code>/<code>ReactNative.Text</code>），使用 props 存放 childrens、其他传入属性等。</p>
<h4 id="3-2-如何生成-React-组件"><a href="#3-2-如何生成-React-组件" class="headerlink" title="3.2 如何生成 React 组件"></a>3.2 如何生成 React 组件</h4><p>从一定角度上来说，<code>React</code> 的组件可以分为两种：</p>
<ul>
<li><strong>元组件</strong> 框架内置的，可以直接用的组件，不同平台有<strong>不同的元组件实现</strong>。</li>
<li><strong>复合组件</strong> 开发者封装之后的组件，一般可以通过 React.createClass 来构建，提供 render() 函数返回渲染元素节点（ ES6 中可以继承 React.Component/PureComponent )。</li>
</ul>
<p>首先，<code>ReactNative</code> 的 <code>js</code>代码都需要通过 <code>AppRegistry.registerComponent</code> 注册对应 appkey 的 Component 才能被启动。我们可以在 <code>AppRegistry.js</code> 中看到它注册了一个对应的回调，在 Native 启动过程中会通过 <code>jsbridge</code> 调用 <code>AppRegistry.runApplication</code> 启动 <code>js</code> 渲染流程，在 <code>js</code> 中会调用对应 <code>runnable</code> ，即后面的<code>renderApplication</code>。</p>
<p>在 <code>renderApplication</code> 时会将传入的 Component 变成 <code>ReactElement</code>，包裹在 <code>AppContainer</code> 中，这个 <code>AppContainer</code> 主要用于外面包围一些 Debug 用的工具（如红盒）。在这之后如上述流程图中一步步走了下去，没什么其他分支，走到 <code>ReactNativeMount</code> 中就会有料出现了，我们来看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">renderComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span><br><span class="line">    nextElement: ReactElement&lt;*&gt;,</span><br><span class="line">    containerTag: number,</span><br><span class="line">    callback?: ?((</span>) =&gt; <span class="title">void</span>)</span><br><span class="line">  ): ?<span class="title">ReactComponent</span>&lt;<span class="title">any</span>, <span class="title">any</span>, <span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将Element使用相同顶层Wrapper包裹，render方法返回child（即nextElement)</span></span><br><span class="line">    <span class="keyword">var</span> nextWrappedElement = React.createElement(</span><br><span class="line">      TopLevelWrapper,</span><br><span class="line">      &#123; child: nextElement &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ReactNativeTagHandles.assertRootTag(containerTag);</span><br><span class="line">    <span class="comment">// 初始化要加载的元素实例</span></span><br><span class="line">    <span class="keyword">var</span> instance = instantiateReactComponent(nextWrappedElement, <span class="literal">false</span>);</span><br><span class="line">    ReactNativeMount._instancesByContainerID[containerTag] = instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The initial render is synchronous but any updates that happen during</span></span><br><span class="line">    <span class="comment">// rendering, in componentWillMount or componentDidMount, will be batched</span></span><br><span class="line">    <span class="comment">// according to the current batching strategy.</span></span><br><span class="line"></span><br><span class="line">    ReactUpdates.batchedUpdates(</span><br><span class="line">      batchedMountComponentIntoNode,</span><br><span class="line">      instance,</span><br><span class="line">      containerTag</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> component = instance.getPublicInstance();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里将传入的 Element 都用 <code>TopLevelWrapper</code> 进行封装，但是它直接透传目标给 <code>render</code> 函数，可以暂时忽略这层。这里通过 <code>instantiateReactComponent</code> 生成了一个渲染对象实例，将 <code>batchedMountComponentIntoNode()</code> 函数提交入回调 Queue，它里面最终会走到 <code>ReactReconciler.mountComponent</code> 里面，直接调用 <code>instance.mountComponent</code>。</p>
<p>接下来就有两处关键地方要理解了：</p>
<ol>
<li><code>instantiateReactComponent</code>利用输入的 <code>ReactElement</code> 生成了什么东西？</li>
<li>利用 <code>instance.mountComponent</code> 怎么进行渲染？</li>
</ol>
<p>在 <code>React</code> 核心库中提供了 <code>instantiateReactComponent.js</code>，供渲染平台调用。它在碰见 <code>ReactElement</code> 时会根据其中的 type 生成<strong>元组件</strong>或者<strong>复合组件</strong>，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node, shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">    instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = node;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Special case string values</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">      instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We renamed this. Allow the old name for compat. :(</span></span><br><span class="line">      <span class="keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">        instance.getHostNode = instance.getNativeNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">    instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    invariant(</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="string">'Encountered invalid React node of type %s'</span>,</span><br><span class="line">      <span class="keyword">typeof</span> node</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将整个代码逻辑总结如下：</p>
<p><img src="/images/instantiateReactComponent.png" alt="instantiateReactComponent"></p>
<h4 id="3-3-复合组件渲染"><a href="#3-3-复合组件渲染" class="headerlink" title="3.3 复合组件渲染"></a>3.3 复合组件渲染</h4><p><img src="/images/js_render_seq.png" alt="js_render_seq"></p>
<p>在挂载根组件的时候，由于根组件是复合组件，它会获取 <code>render()</code> 函数返回的渲染节点，并对它继续走 <code>instantiate</code>/<code>mountComponent</code> 的流程。如果 <code>render()</code> 返回的节点还是自定义的复合组件，那这个流程还会向下走，即：<strong>mount流程会递归向下调用直到最后一个元组件</strong>。</p>
<h4 id="3-4-元组件渲染"><a href="#3-4-元组件渲染" class="headerlink" title="3.4 元组件渲染"></a>3.4 元组件渲染</h4><p><img src="/images/rn_js_element_comp_render_seq.png" alt="rn_js_element_comp_render_seq"></p>
<p>整个元组件也是一个递归渲染的流程，这其中跟复合组件交差挂载，但最终都会转化为元组件进行渲染。</p>
<p><code>React Native</code> 将代码由<code>JSX</code> 转化为 <code>JS</code> 组件，启动过程中利用 <code>instantiateReactComponent</code> 将 <code>ReactElement</code> 转化为复合组件 <code>ReactCompositeComponent</code> 与元组件 <code>ReactNativeBaseComponent</code> ，利用 <code>ReactReconciler</code> 对他们进行渲染。</p>
<h2 id="4、Android-端渲染分析"><a href="#4、Android-端渲染分析" class="headerlink" title="4、Android 端渲染分析"></a>4、Android 端渲染分析</h2><p>从 js 端也就是 <code>UIManager</code> 调用到 Android 端的 <code>UIManagerMoudule</code> 后则进入了 Native 端的渲染流程，整个流程细节比较复杂，但整体对 UI 操作的流程比较规律，见下图：</p>
<p><img src="/images/react_native_ui_manager.png" alt="react_native_ui_manager"></p>
<p>以上就是对整个渲染流程的一个简要分析，希望能对正在研究这块内容的同学有所帮助。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/07/07/gradle-migrate-3.0.0+/" class="prev">上一篇</a><a href="/2017/03/18/stardard_js/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div class="copyright"><p>© 2015 - 2020 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>