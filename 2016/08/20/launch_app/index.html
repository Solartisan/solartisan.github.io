<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android应用启动流程分析 · Solartisan</title><meta name="description" content="Android应用启动流程分析 - imilk"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android应用启动流程分析</h1><div class="post-info">Aug 20, 2016</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">imilk</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p>大家有没有好奇过点击<code>Launcher</code>图标时，到唤起一个应用页面，这个流程会是怎么样的？本文的目的就是尽可能梳理清楚流程，能够让大家对整个流程有一个相对清晰的认知。</p>
<p>在我们开始之前，希望您能最好已经满足以下条件：</p>
<ul>
<li>有一份编译后的Android源码（亲自动手实践才会有更深入的理解）</li>
</ul>
<ul>
<li>对Binder机制有一定的了解</li>
</ul>
<p>本文启动流程分析基于Android 5.1的源码。为什么是5.1的源码呢？因为手边编译完的代码只有这个版本…另外，用什么版本的源码并不重要，大体的流程并无本质上的区别，仅仅是实现细节的调整，找一个你熟悉的版本就好。</p>
<a id="more"></a>
<h2 id="1、启动时序图"><a href="#1、启动时序图" class="headerlink" title="1、启动时序图"></a>1、启动时序图</h2><p>作为一个轻微强迫症的人，整理的时序图，相信大家按图索骥，一定能搞明白整个启动流程：</p>
<p><img src="/images/launcher_app.png" alt="launcher_app"></p>
<p><a href="/images/launcher_app.png">点击放大查看高清无码大图</a></p>
<blockquote>
<p>说明：为了让大家更清楚的理解整个过程，将时序图中划分为三个部分：Launcher进程、System进程、App进程，其中有涉及共用的类以L / A进行区分表示跟哪个进程有关，便于理解。 </p>
</blockquote>
<h2 id="2、关键类说明"><a href="#2、关键类说明" class="headerlink" title="2、关键类说明"></a>2、关键类说明</h2><p>整个启动流程因为会涉及到多次Binder通信，这里先简要说明一下几个类的用途，方便大家理解整个交互流程：</p>
<ul>
<li><strong>ActivityManagerService</strong>：AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。</li>
<li><strong>Instrumentation</strong>：顾名思义，它用来监控应用程序和系统的交互。</li>
<li><strong>ActivityThread</strong>：应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程）。</li>
<li><strong>ApplicationThread</strong>：ApplicationThread提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法。</li>
<li><strong>ActivityManagerProxy</strong>：AMS服务在当前进程的代理类，负责与AMS通信。</li>
<li><strong>ApplicationThreadProxy</strong>：ApplicationThread在AMS服务中的代理类，负责与ApplicationThread通信。</li>
</ul>
<h2 id="3、流程分析"><a href="#3、流程分析" class="headerlink" title="3、流程分析"></a>3、流程分析</h2><p>首先交代下整个流程分析的场景：用户点击Launcher上的应用图标到该应用主界面启动展示在用户眼前。</p>
<p>这整个过程涉及到跨进程通信，所以我们将其划分为时序图中所展示三个进程：Launcher进程、System进程、App进程。为了不贴过长的代码又能说清楚进程间交互的流程，这里简述几个重要的交互点，其他细节流程可参照时序图以及罗升阳老师的<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external"><code>Android应用程序启动过程源代码分析</code></a>来跟踪，虽然罗老师文章中分析源码的版本比较老，但整体流程分析从现在的代码来看依然十分清晰到位。</p>
<p>从时序图上大家也可以看到调用链相当长，对应的代码量也比较大，而且时序图只是分析了这个一个场景下的流程。道阻且长，行则将至！</p>
<h4 id="3-1-Launcher响应用户点击，通知AMS"><a href="#3-1-Launcher响应用户点击，通知AMS" class="headerlink" title="3.1 Launcher响应用户点击，通知AMS"></a>3.1 Launcher响应用户点击，通知AMS</h4><p>Launcher做为应用的入口，还是有必要交代一下的，我们来看看Launcher的代码片段，Launcher使用的是packages/apps/Launcher3的的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">Activity</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>, <span class="title">OnLongClickListener</span>, <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>,</span><br><span class="line">                   <span class="title">View</span>.<span class="title">OnTouchListener</span>, <span class="title">PageSwitchListener</span>, <span class="title">LauncherProviderChangeListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Launches the intent referred by the clicked shortcut.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> v The view representing the clicked shortcut.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure that rogue clicks don't get through while allapps is launching, or after the</span></span><br><span class="line">        <span class="comment">// view has detached (it's possible for this to happen if the view is removed mid touch).</span></span><br><span class="line">        <span class="keyword">if</span> (v.getWindowToken() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        Object tag = v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">            onClickAppShortcut(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> FolderInfo) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == mAllAppsButton) &#123;</span><br><span class="line">            onClickAllAppsButton(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> AppInfo) &#123;</span><br><span class="line">            startAppShortcutOrInfoActivity(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> LauncherAppWidgetInfo) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAppShortcutOrInfoActivity</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">boolean</span> success = startActivitySafely(v, intent, tag);</span><br><span class="line">      	...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            success = startActivity(v, intent, tag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.equals(UserHandleCompat.myUserHandle())) &#123;</span><br><span class="line">                <span class="comment">// Could be launching some bookkeeping activity</span></span><br><span class="line">                startActivity(intent, optsBundle);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过starActicity辗转调用到Activity:startActivityForResult而后则调用至Instrumentation:execStartActivity，代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>ActivityManagerNative.getDefault</code>返回ActivityManagerService的远程接口，即<code>ActivityManagerProxy</code>接口，有人可能会问了为什么会是ActivityManagerProxy，这就涉及到Binder通信了，这里不再展开。通过Binder驱动程序，<code>ActivityManagerProxy</code>与AMS服务通信，则实现了跨进程到System进程。</p>
<h4 id="3-2-AMS响应Launcher进程请求"><a href="#3-2-AMS响应Launcher进程请求" class="headerlink" title="3.2 AMS响应Launcher进程请求"></a>3.2 AMS响应Launcher进程请求</h4><p>从上面的流程我们知道，此时AMS应该处理Launcher进程发来的请求，请参看时序图及源码，此时我们来看ActivityStackSupervisor:startActivityUncheckedLocked方法，目测这个方法已经超过600行代码，来看一些关键代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">DisplayListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityUncheckedLocked</span><span class="params">(ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, </span><br><span class="line">		<span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, Bundle options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Intent intent = r.intent;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> callingUid = r.launchedFromUid;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> launchSingleTop = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> launchSingleInstance = r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> launchSingleTask = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// We'll invoke onUserLeaving before onPause only if the launching</span></span><br><span class="line">		<span class="comment">// activity did not explicitly state that this is an automated launch.</span></span><br><span class="line">		mUserLeaving = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_USER_ACTION) == <span class="number">0</span>;</span><br><span class="line">		...</span><br><span class="line">         </span><br><span class="line">         ActivityRecord notTop =</span><br><span class="line">                (launchFlags &amp; Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != <span class="number">0</span> ? r : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the onlyIfNeeded flag is set, then we can do this if the activity</span></span><br><span class="line">		<span class="comment">// being launched is the same as the one making the call...  or, as</span></span><br><span class="line">		<span class="comment">// a special case, if we do not know the caller then we count the</span></span><br><span class="line">		<span class="comment">// current top activity as the caller.</span></span><br><span class="line">		<span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">// If the caller is not coming from another activity, but has given us an</span></span><br><span class="line">		<span class="comment">// explicit task into which they would like us to launch the new activity,</span></span><br><span class="line">		<span class="comment">// then let's see about doing that.</span></span><br><span class="line">		<span class="keyword">if</span> (sourceRecord == <span class="keyword">null</span> &amp;&amp; inTask != <span class="keyword">null</span> &amp;&amp; inTask.stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">final</span> Intent baseIntent = inTask.getBaseIntent();</span><br><span class="line">			<span class="keyword">final</span> ActivityRecord root = inTask.getRootActivity();</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// If this task is empty, then we are adding the first activity -- it</span></span><br><span class="line">			<span class="comment">// determines the root, and must be launching as a NEW_TASK.</span></span><br><span class="line">			<span class="keyword">if</span> (launchSingleInstance || launchSingleTask) &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">if</span> (inTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sourceRecord == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// This activity is not being started from another...  in this</span></span><br><span class="line">				<span class="comment">// case we -always- start a new task.</span></span><br><span class="line">				<span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span> &amp;&amp; inTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">					Slog.w(TAG, <span class="string">"startActivity called from non-Activity context; forcing "</span> +</span><br><span class="line">                            <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + intent);</span><br><span class="line">					launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">				<span class="comment">// The original activity who is starting us is running as a single</span></span><br><span class="line">				<span class="comment">// instance...  this new activity it is starting must go on its</span></span><br><span class="line">				<span class="comment">// own task.</span></span><br><span class="line">				launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (launchSingleInstance || launchSingleTask) &#123;</span><br><span class="line">				<span class="comment">// The activity being started is a single instance...  it always</span></span><br><span class="line">				<span class="comment">// gets launched into its own task.</span></span><br><span class="line">				launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">         </span><br><span class="line">		...</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// We may want to try to place the new activity in to an existing task.  We always</span></span><br><span class="line">		<span class="comment">// do this if the target activity is singleTask or singleInstance; we will also do</span></span><br><span class="line">		<span class="comment">// this if NEW_TASK has been requested, and there is not an additional qualifier telling</span></span><br><span class="line">		<span class="comment">// us to still place it in a new task: multi task, always doc mode, or being asked to</span></span><br><span class="line">		<span class="comment">// launch this as a new task behind the current one.</span></span><br><span class="line">		<span class="keyword">if</span> (((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (launchFlags &amp; Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == <span class="number">0</span>)</span><br><span class="line">                || launchSingleInstance || launchSingleTask) &#123;</span><br><span class="line">			<span class="comment">// If bring to front is requested, and no result is requested and we have not</span></span><br><span class="line">			<span class="comment">// been given an explicit task to launch in to, and</span></span><br><span class="line">			<span class="comment">// we can find a task that was started with this same</span></span><br><span class="line">			<span class="comment">// component, then instead of launching bring that one to the front.</span></span><br><span class="line">			<span class="keyword">if</span> (inTask == <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// See if there is a task to bring to the front.  If this is</span></span><br><span class="line">				<span class="comment">// a SINGLE_INSTANCE activity, there can be one and only one</span></span><br><span class="line">				<span class="comment">// instance of it in the history, and it is always in its own</span></span><br><span class="line">				<span class="comment">// unique task, so we do a special search.</span></span><br><span class="line">				ActivityRecord intentActivity = !launchSingleInstance ?</span><br><span class="line">					findTaskLocked(r) : findActivityLocked(intent, r.info);</span><br><span class="line">				<span class="keyword">if</span> (intentActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">					...</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">      </span><br><span class="line">		...</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (r.packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the activity being launched is the same as the one currently</span></span><br><span class="line">            <span class="comment">// at the top, then we need to check if it should only be launched</span></span><br><span class="line">            <span class="comment">// once.</span></span><br><span class="line">            ActivityStack topStack = getFocusedStack();</span><br><span class="line">            ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123;</span><br><span class="line">                	...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         	...</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">		<span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span> keepCurTransition = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != <span class="keyword">null</span> ?</span><br><span class="line">                sourceRecord.task : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Should this be considered a new task?</span></span><br><span class="line">		<span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span> &amp;&amp; inTask == <span class="keyword">null</span> &amp;&amp; !addingToTask</span><br><span class="line">                &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> (reuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.setTask(targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                        newTaskInfo != <span class="keyword">null</span> ? newTaskInfo : r.info,</span><br><span class="line">                        newTaskIntent != <span class="keyword">null</span> ? newTaskIntent : intent,</span><br><span class="line">                        voiceSession, voiceInteractor, !launchTaskBehind <span class="comment">/* toTop */</span>),</span><br><span class="line">                        taskToAffiliate);</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.setTask(reuseTask, taskToAffiliate);</span><br><span class="line">            &#125;</span><br><span class="line">             ...</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">          </span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addingToTask &amp;&amp;</span><br><span class="line">                    (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != <span class="number">0</span>) &#123;</span><br><span class="line">                      </span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (inTask != <span class="keyword">null</span>)&#123;</span><br><span class="line">          </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">		&#125;</span><br><span class="line">      </span><br><span class="line">		...</span><br><span class="line">      </span><br><span class="line">		targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">         </span><br><span class="line">		...</span><br><span class="line">         <span class="keyword">return</span> ActivityManager.START_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数经过intent的标志值设置，通过findTaskLocked函数来查找存不存这样的Task，这里返回的结果是null，即intentActivity为null，因此，需要创建一个新的Task来启动这个Activity。现在处理堆栈顶端的Activity是Launcher，与我们即将要启动的MainActivity不是同一个Activity，创建了一个新的Task里面来启动这个Activity。</p>
<p>经过栈顶检测，则需要将Launcher推入Paused状态，才可以启动新的Activity。后续则调用至ActivityStack:startPausingLocked，我们来看一下这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStack</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping, <span class="keyword">boolean</span> resuming,</span><br><span class="line">            <span class="keyword">boolean</span> dontWait)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    ...</span><br><span class="line">	  &#125; </span><br><span class="line">	  ActivityRecord prev = mResumedActivity;</span><br><span class="line">	  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    ...</span><br><span class="line">	  &#125;</span><br><span class="line">	  ...</span><br><span class="line">	  mResumedActivity = <span class="keyword">null</span>;</span><br><span class="line">	  mPausingActivity = prev;</span><br><span class="line">	  mLastPausedActivity = prev;</span><br><span class="line">	  mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></span><br><span class="line">                || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span> ? prev : <span class="keyword">null</span>;</span><br><span class="line">	  prev.state = ActivityState.PAUSING;</span><br><span class="line">	  ...</span><br><span class="line">		</span><br><span class="line">	  <span class="keyword">if</span> (prev.app != <span class="keyword">null</span> &amp;&amp; prev.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">	      <span class="keyword">try</span> &#123;</span><br><span class="line">		  ...</span><br><span class="line">		  prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">	      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		  ...</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	      ...</span><br><span class="line">	  &#125;</span><br><span class="line">	  ...</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的prev.app.thread是一个ApplicationThread对象的远程接口，通过调用这个远程接口的schedulePauseActivity来通知Launcher进入Paused状态。至此，AMS对Launcher的请求已经响应，这是我们发现又通过Binder通信回调至Launcher进程。</p>
<h4 id="3-3-Launcher进程挂起Launcher，再次通知AMS"><a href="#3-3-Launcher进程挂起Launcher，再次通知AMS" class="headerlink" title="3.3 Launcher进程挂起Launcher，再次通知AMS"></a>3.3 Launcher进程挂起Launcher，再次通知AMS</h4><p>这个流程相对会简单一些，我们来看ActivityThread:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,</span><br><span class="line">            <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell the activity manager we have paused.</span></span><br><span class="line">            <span class="keyword">if</span> (!dontReport) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分Launcher的ActivityThread处理页面Paused并且再次通过ActivityManagerProxy通知AMS。</p>
<h4 id="3-4-AMS创建新的进程"><a href="#3-4-AMS创建新的进程" class="headerlink" title="3.4 AMS创建新的进程"></a>3.4 AMS创建新的进程</h4><p>创建新进程的时候，AMS会保存一个ProcessRecord信息，如果应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称。每一个应用程序都有自己的uid，因此，这里uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType, String 	hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">	  ...</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	      ...</span><br><span class="line">	      <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">	      <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">	      <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">	      <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">	      Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">	      ...</span><br><span class="line">	  &#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line">	      ...</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是调用Process:start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数，这就是每一个应用程序都有一个ActivityThread实例来对应的原因。</p>
<h4 id="3-5-应用进程初始化"><a href="#3-5-应用进程初始化" class="headerlink" title="3.5 应用进程初始化"></a>3.5 应用进程初始化</h4><p>我们来看Activity的main函数，这里绑定了主线程的Looper，并进入消息循环，大家应该知道，整个Android系统是消息驱动的，这也是为什么主线程默认绑定Looper的原因：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    ...</span><br><span class="line">	    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">	    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">	    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	    ...</span><br><span class="line"></span><br><span class="line">	    Looper.loop();</span><br><span class="line">      </span><br><span class="line">	    ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">	    ...</span><br><span class="line">	    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">	        ...</span><br><span class="line">	        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            mgr.attachApplication(mAppThread);</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">	            <span class="comment">// Ignore</span></span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        ...</span><br><span class="line">	    &#125;</span><br><span class="line">	    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attach函数最终调用了ActivityManagerService的远程接口ActivityManagerProxy的attachApplication函数，传入的参数是mAppThread，这是一个ApplicationThread类型的Binder对象，它的作用是AMS与应用进程进行进程间通信的。</p>
<h4 id="3-6-在AMS中注册应用进程，启动启动栈顶页面"><a href="#3-6-在AMS中注册应用进程，启动启动栈顶页面" class="headerlink" title="3.6 在AMS中注册应用进程，启动启动栈顶页面"></a>3.6 在AMS中注册应用进程，启动启动栈顶页面</h4><p>前面我们提到了AMS负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，通过上一个流程我们知道应用进程创建后通过Binder驱动与AMS产生交互，此时AMS则将应用进程创建后的信息进行了一次<code>注册</code>，如果拿Windows系统程序注册到的注册表来理解这个过程，可能会更形象一些。</p>
<p>mMainStack.topRunningActivityLocked(null)从堆栈顶端取出要启动的Activity，并在realStartActivityLockedhan函数中通过ApplicationThreadProxy调回App进程启动页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">implements</span> <span class="title">DisplayListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">            ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span></span><br><span class="line">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">	    ...</span><br><span class="line">	    r.app = app;</span><br><span class="line">	    ...</span><br><span class="line">          </span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	      ...</span><br><span class="line">	      app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                    r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState,</span><br><span class="line">                    r.icicle, r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">	      ...</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">	      ...</span><br><span class="line">	    &#125;</span><br><span class="line">	    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在App进程，我们可以看到，经过一些列的调用链最终调用至MainActivity:onCreate函数，之后会调用至onResume，而后会通知AMS该MainActivity已经处于resume状态。至此，整个启动流程告一段落。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>通过上述流程，相信大家可以有了一个基本的认知，这里我们忽略细节简化流程，单纯从进程角度来看下图： <img src="/images/launch_app_sim.png" alt="launch_app_sim"></p>
<p>图上所画这里就不在赘述，Activity启动后至Resume状态，此时可交互。欢迎大家指正交流。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/15/framework_token/" class="prev">上一篇</a><a href="/2016/07/11/learn_plugin/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div data-thread-key="2016/08/20/launch_app/" data-title="Android应用启动流程分析" data-url="http://solart.cc/2016/08/20/launch_app/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"solart"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://solart.cc">imilk</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>