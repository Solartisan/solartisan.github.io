<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 都是 Push 惹的祸 · Solartisan</title><meta name="description" content="都是 Push 惹的祸 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">都是 Push 惹的祸</h1><div class="post-info">Dec 6, 2016</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">solart</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p>这是一篇 KPI 考核背景下产出的文章，这一切都起源于我司要求提升 App 推送送达率，以节省在短信推广上花费的开销。这里记录了在整个技术调研的关键点。</p>
<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><code>iOS</code> 和 <code>Android</code> 均在系统级集成了推送服务，来说说<code>原生 Android</code> 的推送服务，最在 Android 2.2 时，<code>C2DM</code> 作为系统级服务集成进了 <code>Android</code> 系统，而 <code>GCM（Google Clould Messaging）</code> 在 2013 Google IO 大会发布后就正式取代了 <code>C2DM</code> ，然后 Google 并没有止步，在 2014 年收购了 <a href="https://en.wikipedia.org/wiki/Firebase" target="_blank" rel="external"><code>Firebase</code></a> ，经过近两年的整合，在 2016 年 Google IO 大会上隆重发布了 Firebase 服务，一个全新的移动和 Web 开发的完整后端解决方案，其中就包括了<code>FCM（Firebase Cloud Messaging）</code>。如果就这么简单，我们就可以在 Android 平台上像 iOS 平台一样使用系统级共享的推送服务了，然而一股神秘的东方力量打破了原本简单的事情…</p>
<a id="more"></a>
<p>众所周知 Google 退出中国市场后，各家厂商在 <code>Android</code> 底层的定制修改，使得国内 <code>Android</code> 平台更加分化。其中小米推出了自家的 MiPush ，华为也推出了自家的 Push ，BAT 的推送、极光、个推等等推送平台，这也使得开发者选择时不知所措。据我所知现在很多 App 都接入了多家推送以保证推送的送达率。不同的推送平台也会针对接入自家推送 SDK 的 App 互相唤起，这也是为了保证自家推送送达率，否则送达低了谁还用呢，毕竟企业也是要生存的。其实这正是国内 <code>Android</code> 的乱象之一，这也使得 <code>Android</code> 的用户抱怨不断，实在是进入了一个怪圈之中。</p>
<p>以上说了这么多，并不能解决我们的问题，既然存在于这个大环境之中，我们就只能想些办法去适应它。</p>
<h2 id="2、推送及保活"><a href="#2、推送及保活" class="headerlink" title="2、推送及保活"></a>2、推送及保活</h2><p>下面就简单先说说推送服务的实现机制，简单点，看图说话：</p>
<p><img src="/images/push_model.png" alt="push_model"></p>
<p>这就是一个非常简单的推送模型，服务器向 Push 服务器发布推送消息，推送服务器经过处理按照要求将推送消息通过长链接通道将消息推送至 App 。</p>
<h4 id="2-1-皮之不存，毛将焉附"><a href="#2-1-皮之不存，毛将焉附" class="headerlink" title="2.1 皮之不存，毛将焉附"></a>2.1 皮之不存，毛将焉附</h4><p>我们知道 Push 服务器想要成功的将消息推送至客户端真正的关键就是这个长链接的稳定性，各家推送服务也都对这个长链接做了很多优化，比如通道共享、透传等。对于 <code>Android</code> 来说通常的做法是通过 <code>Service</code> 维持一个长链接，定时发送心跳包以保证实时在线。</p>
<p>推送 <code>Service</code> 依赖于应用进程的状态，进程作为载体，进程处于运行状态，<code>Service</code> 才能正常工作，一但进程被杀死，推送 <code>Service</code> 自然也无法运行，进而也就无法收到推送消息。</p>
<p>那么我们首先解决进程存活的问题，在这之前，简单的说明一下进程及资源的冲突问题，大家应该知道，每个进程的启动都意味着消耗掉一部分手机资源，比如 CPU ，内存等。而像内存这样的资源在手机中其实是相当宝贵的，系统为了保证自身运行的稳定性以及前台 App 的性能，在必要时会触发资源回收的机制，在 Android 中这种机制被称之为 <code>LowMemoryKiller</code> 。</p>
<h4 id="2-2-进程杀手-LMK"><a href="#2-2-进程杀手-LMK" class="headerlink" title="2.2 进程杀手 LMK"></a>2.2 进程杀手 LMK</h4><p><code>LowMemoryKiller</code> 是一种根据 <code>OOM_ADJ</code> 阈值级别触发相应力度的内存回收的机制。什么是 <code>OOM_ADJ</code> 呢？ OOM 想必大家都知道就不在解释了，<code>ADJ</code> 何解？ <code>Adjustment</code>，调整，即内存溢出调整的阈值。<code>LMK</code> 回收内存时会根据进程的级别优先杀死 <code>OOM_ADJ</code> 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。关于这部分内容大家可以参看 <a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="external">Android LowMemoryKiller 原理分析</a>这篇文章，今天并不主要分析源码，我们开看一个关于 OOM_ADJ 的对应表（参照源码  <code>com.android.server.am.ProcessList</code> 中定义的取值整理）。</p>
<p><img src="/images/oom_adj.png" alt="oom_adj"></p>
<p>其中红色部分代表比较容易被杀死的 Android 进程（ OOM_ADJ &gt;= 4 ）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。</p>
<h4 id="2-3-进程保活"><a href="#2-3-进程保活" class="headerlink" title="2.3 进程保活"></a>2.3 进程保活</h4><p>根据以上的信息，我们就要想方设法降低我们应用的 OOM_ADJ 的值，那么怎么降低呢？这时候就依赖翻看一些源码了，在 <code>ActivityManagerService</code> 中有一个 <code>updateOomAdjLocked</code> 函数，在许多地方被调用去更新应用的 OOM_ADJ 值，在这个函数的调用链中我们找到一个 <code>computeOomAdjLocked</code> 函数用于计算 App 的 OOM_ADJ 的值，以下我们截取部分代码做简单分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">computeOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP,</span><br><span class="line">            <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine the importance of the process, starting with most</span></span><br><span class="line">        <span class="comment">// important to least, and assign an appropriate OOM adjustment.</span></span><br><span class="line">        <span class="keyword">int</span> adj;</span><br><span class="line">        <span class="keyword">int</span> schedGroup;</span><br><span class="line">        <span class="keyword">int</span> procState;</span><br><span class="line">        <span class="keyword">boolean</span> foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line">        BroadcastQueue queue;</span><br><span class="line">        <span class="keyword">if</span> (app == TOP_APP) &#123;</span><br><span class="line">            <span class="comment">// The last app on the list is the foreground app.</span></span><br><span class="line">            <span class="comment">// 列表中的最后一个应用程序是前台应用程序,这取决于用户的操作，我们无法干预。</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">            app.adjType = <span class="string">"top-activity"</span>;</span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instrumentationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Don't want to kill running instrumentation.</span></span><br><span class="line">            <span class="comment">// 这个case可以尝试，可将 app adj 值降低至 0</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">            app.adjType = <span class="string">"instrumentation"</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((queue = isReceivingBroadcast(app)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// An app that is currently receiving a broadcast also</span></span><br><span class="line">            <span class="comment">// counts as being in the foreground for OOM killer purposes.</span></span><br><span class="line">            <span class="comment">// It's placed in a sched group based on the nature of the</span></span><br><span class="line">            <span class="comment">// broadcast as reflected by which queue it's active in.</span></span><br><span class="line">            <span class="comment">// 这个 case 要求 app 正在或将要接收广播,可以尝试但操作难度较高</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = (queue == mFgBroadcastQueue)</span><br><span class="line">                    ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">            app.adjType = <span class="string">"broadcast"</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_RECEIVER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.executingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// An app that is currently executing a service callback also</span></span><br><span class="line">            <span class="comment">// counts as being in the foreground.</span></span><br><span class="line">            <span class="comment">// 一个正在执行代码的 Service 可将 adj 的值调整至 0</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = app.execServicesFg ?</span><br><span class="line">                    Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">            app.adjType = <span class="string">"exec-service"</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">            <span class="comment">//Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// As far as we know the process is empty.  We may change our mind later.</span></span><br><span class="line">            schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">            <span class="comment">// At this point we don't actually know the adjustment.  Use the cached adj</span></span><br><span class="line">            <span class="comment">// value that the caller wants us to.</span></span><br><span class="line">            adj = cachedAdj;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">            app.cached = <span class="keyword">true</span>;</span><br><span class="line">            app.empty = <span class="keyword">true</span>;</span><br><span class="line">            app.adjType = <span class="string">"cch-empty"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Examine all activities if not already foreground.</span></span><br><span class="line">        <span class="keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord r = app.activities.get(j);</span><br><span class="line">                <span class="keyword">if</span> (r.app != app) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Wtf, activity "</span> + r + <span class="string">" in proc activity list not using proc "</span></span><br><span class="line">                            + app + <span class="string">"?!?"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r.visible) &#123;</span><br><span class="line">                    <span class="comment">// App has a visible activity; only upgrade adjustment.</span></span><br><span class="line">                    <span class="comment">// 维护一个用户不可见的 Activity 可以将应用的 adj 降低至 1</span></span><br><span class="line">                    <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">                        adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">                        app.adjType = <span class="string">"visible"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                        procState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">                    &#125;</span><br><span class="line">                    schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">                    app.cached = <span class="keyword">false</span>;</span><br><span class="line">                    app.empty = <span class="keyword">false</span>;</span><br><span class="line">                    foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">            <span class="comment">// 维护一个前台 Service 可将 app adj值降低至 2.</span></span><br><span class="line">            <span class="keyword">if</span> (app.foregroundServices) &#123;</span><br><span class="line">                <span class="comment">// The user is aware of this app, so make it visible.</span></span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">                app.cached = <span class="keyword">false</span>;</span><br><span class="line">                app.adjType = <span class="string">"fg-service"</span>;</span><br><span class="line">                schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.forcingToForeground != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The user is aware of this app, so make it visible.</span></span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">                app.cached = <span class="keyword">false</span>;</span><br><span class="line">                app.adjType = <span class="string">"force-fg"</span>;</span><br><span class="line">                app.adjSource = app.forcingToForeground;</span><br><span class="line">                schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过我们的分析，我们可以从以下几个方面尝试：</p>
<ul>
<li>尝试在 Manifest 中注册一个 Instrumentation</li>
<li>尝试维护一个用户无法感知的 Activity</li>
<li>尝试维持一个前台 Service</li>
</ul>
<p>其他还可以考虑永动机式的 Service 及不停的收发广播这两种变态的方案，在实践中考虑到对性能及的耗电量的影响，这两条并没有尝试。基于以上的分析可将 App 的 OOM_ADJ 的降低至 2，最低可以降低至 0。</p>
<p>那么在开始之前我们先看看 App 没有经过以上方案的处理，它的 OOM_ADJ 的值如何，最为对比参考。</p>
<p>我们启动 App 通过 <code>ps</code> 命令查看进程对应的 <code>pid</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ ps | grep solart</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u0_a250   3855  162   931684 43932 ffffffff 00000000 S cc.solart.nuts</span><br></pre></td></tr></table></figure>
<p> 我们再通过 <code>cat</code> 命令查看 oom_adj 的值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ cat /proc/3855/oom_adj</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p>通过按 Home 键，在查看 oom_adj 的值，输出为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p>通过按 Back 键盘退出页面，oom_adj 的值输出为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<p>大家可以看到我们什么都没做的时候，App 进入后台和页面退出后 OOM_ADJ 的值其实已经非常高了，如果此时系统内存紧张，则有比较大的概率会被干掉。</p>
<p>下面我们尝试保活方案：</p>
<p><strong>尝试在 Manifest 中注册一个 Instrumentation</strong>：这个方案在执行时验证无效，并没有有效的降低 adj 值，至于为什么不能生效，还没有搞得太明白。</p>
<p><strong>尝试维护一个用户无法感知的 Activity</strong>：这个方案确实有效的降低了adj的值，但在实际测试过程中发现，在某些机器上因为广播延迟的原因 Activity 无法及时销毁，导致亮屏幕后有一瞬间用户是无法操作的，这个方案被 Pass。</p>
<p><strong>尝试维持一个前台 Service</strong>： 这是一个行之有效的方案，在实际过程中发现发送空 Notification 在某些机型上会发生异常，后又改为有内容的通知，但这会在通知栏上闪一下，但通过测试发现确实能够有效让 App 的 adj 值维持在 2 的水平。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Nullable</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Log.d(<span class="string">"nuts"</span>, <span class="string">"KeepAliveService onStartCommand invoke"</span>);</span><br><span class="line">            startForeground(NOTIFICATION_ID, getNotification(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">            Intent innerIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, InnerService.class);</span><br><span class="line">            startService(innerIntent);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//nothing to do</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用系统自启</span></span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Nullable</span></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Log.d(<span class="string">"nuts"</span>, <span class="string">"InnerService onStartCommand invoke"</span>);</span><br><span class="line">                startForeground(NOTIFICATION_ID, getNotification(<span class="keyword">this</span>));</span><br><span class="line">                stopSelf();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//nothing to do</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Notification <span class="title">getNotification</span><span class="params">(Context ctx)</span></span>&#123;</span><br><span class="line">        Notification notify = <span class="keyword">new</span> NotificationCompat.Builder(ctx)</span><br><span class="line">                .setSmallIcon(R.drawable.ic_launcher)</span><br><span class="line">                .setContentTitle(<span class="string">""</span>)</span><br><span class="line">                .setContentText(<span class="string">""</span>)</span><br><span class="line">                .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> notify;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并在 Manifest 中生命这两个 Service 组件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;service android:name=&#34;.push.KeepAliveService&#34; /&#62;&#10;&#10;&#60;service android:name=&#34;.push.KeepAliveService$InnerService&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>通过按压 Home/Back 键，再次通过 cat 命令查看 oom_adj 的值，输出为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>大家对比我们不做处理时的 oom_adj 值，可以明显看到差别。</p>
<h2 id="3、进程唤醒"><a href="#3、进程唤醒" class="headerlink" title="3、进程唤醒"></a>3、进程唤醒</h2><p>通过以上保活的策略确实让 App 避免过快的被系统干掉，但用户经常手动清理，也是一个比较头疼的问题，那如何能够在 App 被杀死后将其唤起，则成为了第二阶段的目标。</p>
<h4 id="3-1-大树底下好乘凉"><a href="#3-1-大树底下好乘凉" class="headerlink" title="3.1 大树底下好乘凉"></a>3.1 大树底下好乘凉</h4><p>市面上推送 SDK 选择非常多，我们在集成推送 SDK 时又不想每个都集成一遍，这个时候我们就需要耍些花招了，大家知道，用户活跃度高的 App 大多是 BAT 系的，我们不妨就从这里入手，自己体系的 App 大都会集成自家的推送服务（你可以反编译几个看看，反编译微信并没有发现其用到什么推送，想想本身微信也是即时通讯类的 App 也就明白了）。这里我们就拿百度推送 SDK 开刀了，首先官网下载 SDK 包，其中找到开发文档，阅读 SDK 集成方法，从中找到蛛丝马迹，具体过程就不在赘述了，大家自己去看一下，就能够明白。</p>
<p>在百度推送 SDK 中，我们发现在 <code>CommandService</code> 中有这么一段被混淆的代码，但仍然不妨碍我们去大致猜测其实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(Intent var1)</span> </span>&#123;</span><br><span class="line">        String var2 = t.c(<span class="keyword">this</span>, <span class="keyword">this</span>.getPackageName(), var1.getAction());</span><br><span class="line">        t.b(<span class="string">"CommandService#onStartCommand#reflectReceiver#recevier = "</span> + var2, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(var2)) &#123;</span><br><span class="line">            a.b(<span class="string">"CommandService"</span>, <span class="string">" reflectReceiver error: receiver for: "</span> + var1.getAction() + <span class="string">" not found, package: "</span> + <span class="keyword">this</span>.getPackageName());</span><br><span class="line">            var1.setPackage(<span class="keyword">this</span>.getPackageName());</span><br><span class="line">            <span class="keyword">this</span>.sendBroadcast(var1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class var3 = Class.forName(var2);</span><br><span class="line">                Constructor var4 = var3.getConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">                Object var5 = var4.newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">                String[] var10000 = <span class="keyword">new</span> String[]&#123;<span class="string">"android.content.Context"</span>, <span class="string">"android.content.Intent"</span>&#125;;</span><br><span class="line">                Class[] var7 = <span class="keyword">new</span> Class[]&#123;Context.class, Intent.class&#125;;</span><br><span class="line">                Method var8 = var3.getMethod(<span class="string">"onReceive"</span>, var7);</span><br><span class="line">                var1.setClassName(<span class="keyword">this</span>.getPackageName(), var2);</span><br><span class="line">                Object[] var9 = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>.getApplicationContext(), var1&#125;;</span><br><span class="line">                var8.invoke(var5, var9);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">                a.a(<span class="string">"CommandService"</span>, var11);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们发现百度通过反射 <code>BroadcastReceiver</code> 中 <code>onReceive</code> 函数调用来唤醒集成了百度推送的 App ，那既然如此我们干脆测试一下，将百度的 <code>RegistrationReceiver</code> 做壳，在其中启动自己的推送服务，接下来就简单的做壳及在 Manifest 中注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistrationReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"nuts"</span>, <span class="string">"baidu onReceiver invoke"</span>);</span><br><span class="line">        Intent daemonIntent = <span class="keyword">new</span> Intent(context, KeepAliveService.class);</span><br><span class="line">        context.startService(daemonIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动杀死自己的 App 模拟被系统杀死，通过 logcat 过滤 log 并启动百度地图或其他百度系 App 输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb logcat -s nuts</span><br><span class="line">--------- beginning of /dev/log/system</span><br><span class="line">--------- beginning of /dev/log/main</span><br><span class="line">D/nuts    (<span class="number">12804</span>): baidu onReceiver invoke</span><br><span class="line">D/nuts    (<span class="number">20650</span>): KeepAliveService onStartCommand invoke</span><br><span class="line">D/nuts    (<span class="number">20650</span>): InnerService onStartCommand invoke</span><br></pre></td></tr></table></figure>
<p>通过以上 log 我们就看出通过其他 App 成功将我们自己的 App 唤醒了。通过这种方式，我们还可以去尝试其他现象级 App 或号称自己具有唤醒功能的推送 SDK ，这个就是个工作量的问题了，就不在介绍。当然有些 App 间通过指定应用包名唤醒，面对这样的方式我们就无能为力了。</p>
<p>在实际测试中发现，部分机型 ROM 阻断了应用间唤醒，这个招式并不能覆盖到全部机型。</p>
<h4 id="3-2-打铁还需自身硬"><a href="#3-2-打铁还需自身硬" class="headerlink" title="3.2 打铁还需自身硬"></a>3.2 打铁还需自身硬</h4><p>俗话说打铁还需自身硬，求人不如靠自己。在 Android 5.0 以后系统收紧了进程的管理，以节约用户电量消耗，但仍然提供以一个新的 <a href="https://developer.android.com/reference/android/app/job/JobScheduler.html" target="_blank" rel="external"><code>JobScheduler</code></a> API ，允许应用在某个时间或者指定的条件下（例如，设备充电时）异步执行任务。官方推出这个 API 的出发点是好的，但也让我们有空子可钻。</p>
<p>我们先来通过继承 <code>JobService</code> 来实现一个 <code>WakeUpService</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TargetApi</span>(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakeUpService</span> <span class="keyword">extends</span> <span class="title">JobService</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters jobParameters)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"nuts"</span>, <span class="string">"WakeUpService onStartJob"</span>);</span><br><span class="line">        <span class="comment">// to start push service or something else</span></span><br><span class="line">        Intent daemonIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, KeepAliveService.class);</span><br><span class="line">        startService(daemonIntent);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters jobParameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startJobScheduler</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> jobId = <span class="number">1002</span>;</span><br><span class="line">            JobInfo.Builder builder = <span class="keyword">new</span> JobInfo.Builder(jobId, <span class="keyword">new</span> ComponentName(ctx, WakeUpService.class));</span><br><span class="line">            <span class="comment">// 调整启动 service 间隔时间，这里为了测试随意写了 5 秒</span></span><br><span class="line">            builder.setPeriodic(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">            builder.setPersisted(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            JobScheduler jobScheduler = (JobScheduler) ctx.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">            jobScheduler.schedule(builder.build());</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的在 Manifest 中注册这个服务:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">android:name</span>=<span class="value">".push.WakeUpService"</span></span><br><span class="line">         <span class="attribute">android:permission</span>=<span class="value">"android.permission.BIND_JOB_SERVICE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>再次杀掉进程观察 log 输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ adb logcat -s nuts&#10;- waiting for device -&#10;--------- beginning of /dev/log/system&#10;--------- beginning of /dev/log/main&#10;11-28 16:34:35.821  5675  5675 D nuts    : WakeUpService onStartJob&#10;11-28 16:34:35.821  5675  5675 D nuts    : KeepAliveService onStartCommand invoke&#10;11-28 16:34:35.841  5675  5675 D nuts    : InnerService onStartCommand invoke&#10;11-28 16:34:40.871  5675  5675 D nuts    : WakeUpService onStartJob&#10;11-28 16:34:40.881  5675  5675 D nuts    : KeepAliveService onStartCommand invoke&#10;11-28 16:34:40.901  5675  5675 D nuts    : InnerService onStartCommand invoke&#10;11-28 16:34:45.931  5675  5675 D nuts    : WakeUpService onStartJob&#10;11-28 16:34:45.931  5675  5675 D nuts    : KeepAliveService onStartCommand invoke&#10;11-28 16:34:45.951  5675  5675 D nuts    : InnerService onStartCommand invoke</span><br></pre></td></tr></table></figure>
<p>我们看到 App 被杀死后，还是被唤起了。即使通过一键清理仍然能够唤醒，目前经过测试在 5.0 之后的机型还暂没有遇到不能唤醒的 case 。当然如果厂商将你的 App 加入了黑名单那是无论如何也起不来了。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>当然除了这些手段，还针对通知权限做了一些研究，在 Android 4.3/4.4 上可以强行打开用户通知权限，在 5.0 后谷歌爸爸修复了这个漏洞，由于覆盖版本较小，这里就不在分享。</p>
<p>以上我们通过种种手段将 App 做到了即使在后台依然能够使 OOM_ADJ 的值维持在 2 的水平，从而有效的提升了 Push 的送达率。而大家在选择 Push 服务时可以多考虑小米、华为这样厂商支持的推送，毕竟在自家的平台上还是比一般的推送有系统级进程的优势存在。在 Google 服务无法回归的情况下，如果诸多厂商联合起来推出一个 Push 服务…算了不在 YY 了。</p>
<p>最后，以上所有手段请慎重使用！</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/01/23/react-native-custom-view/" class="prev">上一篇</a><a href="/2016/11/25/va_hook/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div class="copyright"><p>© 2015 - 2020 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>