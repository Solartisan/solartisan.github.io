<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 插件化中 Classloader 的加载 dex 分析 · Solartisan</title><meta name="description" content="插件化中 Classloader 的加载 dex 分析 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">插件化中 Classloader 的加载 dex 分析</h1><div class="post-info">Nov 16, 2016</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">solart</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<h2 id="1、Java-类加载器"><a href="#1、Java-类加载器" class="headerlink" title="1、Java 类加载器"></a>1、Java 类加载器</h2><p>提到 Android 插件化，一个基础的知识点就是 Java 的类加载机制。这部分知识请参考<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">深入探讨 Java 类加载器</a>，以下摘录部分内容。</p>
<h4 id="1-1-类加载器的树状组织结构"><a href="#1-1-类加载器的树状组织结构" class="headerlink" title="1.1 类加载器的树状组织结构"></a>1.1 类加载器的树状组织结构</h4><p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p>
<ul>
<li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 <code>java.lang.ClassLoader</code>。</li>
</ul>
<ul>
<li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。</li>
</ul>
<a id="more"></a>
<h4 id="1-2-类加载器的代理模式"><a href="#1-2-类加载器的代理模式" class="headerlink" title="1.2 类加载器的代理模式"></a>1.2 类加载器的代理模式</h4><p><code>类加载器</code>在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<h4 id="1-3-加载类的过程"><a href="#1-3-加载类的过程" class="headerlink" title="1.3 加载类的过程"></a>1.3 加载类的过程</h4><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 <code>defineClass</code>来实现的；而启动类的加载过程是通过调用 <code>loadClass</code>来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。更多细节可参考<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">深入探讨 Java 类加载器</a>。</p>
<h2 id="2、DexClassLoader-和-PathClassLoader"><a href="#2、DexClassLoader-和-PathClassLoader" class="headerlink" title="2、DexClassLoader 和 PathClassLoader"></a>2、DexClassLoader 和 PathClassLoader</h2><p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为 JVM 方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>Android Framework简化了<code>通过一个类的全限定名获取描述次类的二进制字节流</code>这个过程；我们只需要告诉ClassLoader 一个 dex 文件或者 apk 文件的路径就能完成类的加载。</p>
<p>在 Android 中，ClassLoader 是一个抽象类，实际开发过程中，我们一般是使用其具体的子类 DexClassLoader、PathClassLoade r这些类加载器来加载类的，它们的不同之处是：</p>
<ul>
<li><strong>DexClassLoader:</strong> 从 .jar 和 .apk 文件加载包含 classes.dex 条目的类。 这可以用于执行未作为应用程序的一部分安装的代码。</li>
</ul>
<ul>
<li><strong>PathClassLoader:</strong> 对本地文件系统中的文件和目录列表进行操作，但不尝试从网络加载类。 Android 将此类用于其系统类加载器及其应用程序类加载器。</li>
</ul>
<p>看一下 DexClassLoader 和 PathClassLoader 细节上的区别:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span><br><span class="line">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上可以看出来这两者只是对<code>BaseDexClassLoader</code>做了简单的封装，不同的是<code>PathClassLoader</code>在父类的构造中 optimizedDirectory 是 null，再来看BaseDexClassLoader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span><br><span class="line">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中创建了一个<code>DexPathList</code>实例，我们再来看看这个类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.definingContext = definingContext;</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Makes an array of dex/resource path elements, one per element of</span><br><span class="line">     * the given array.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                             ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Open all files and load the (direct or contained) dex files</span><br><span class="line">         * up front.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            File zip = <span class="keyword">null</span>;</span><br><span class="line">            DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">// We support directories for looking up resources.</span></span><br><span class="line">                <span class="comment">// This is only useful for running libcore tests.</span></span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                    <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                        System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    zip = file;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                        suppressedExceptions.add(suppressed);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * Constructs a &#123;<span class="doctag">@code</span> DexFile&#125; instance, as appropriate depending</span><br><span class="line">     * on whether &#123;<span class="doctag">@code</span> optimizedDirectory&#125; is &#123;<span class="doctag">@code</span> null&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123; <span class="comment">//如果为空则直接创建DexFile</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Converts a dex/jar file path and an output directory to an</span><br><span class="line">     * output file path for an associated optimized dex file.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path,</span><br><span class="line">            File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Get the filename component of the path, and replace the</span><br><span class="line">         * suffix with ".dex" if that's not already the suffix.</span><br><span class="line">         *</span><br><span class="line">         * We don't want to use ".odex", because the build system uses</span><br><span class="line">         * that for files that are paired with resource-only jar</span><br><span class="line">         * files. If the VM can assume that there's no classes.dex in</span><br><span class="line">         * the matching jar, it doesn't need to open the jar to check</span><br><span class="line">         * for updated dependencies, providing a slight performance</span><br><span class="line">         * boost at startup. The use of ".dex" here matches the use on</span><br><span class="line">         * files in /data/dalvik-cache.</span><br><span class="line">         */</span></span><br><span class="line">        String fileName = path.getName();</span><br><span class="line">        <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                fileName += DEX_SUFFIX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</span><br><span class="line">                sb.append(fileName, <span class="number">0</span>, lastDot);</span><br><span class="line">                sb.append(DEX_SUFFIX);</span><br><span class="line">                fileName = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</span><br><span class="line">        <span class="keyword">return</span> result.getPath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexFileList 创建了一个 dex 资源路径的元素数组，在向这个数组添加元素时，会根据 optimizedDirectory 参数是否为 null 来区分创建 DexFile 对象。所以呢，PathClassLoader 最后调用的是 new DexFile(pathFile)，而DexClassLoader 调用的是 DexFile.loadDex(dexPathList[i], outputName, 0)。</p>
<p>这里还需要提一下的是官方文档中 <a href="https://developer.android.com/reference/dalvik/system/DexClassLoader.html" target="_blank" rel="external">DexClassLoader</a> 中写到这样一段话：</p>
<blockquote>
<p><strong>Do not cache optimized classes on external storage.</strong> External storage does not provide access controls necessary to protect your application from code injection attacks.</p>
</blockquote>
<h2 id="3、Dex-加载"><a href="#3、Dex-加载" class="headerlink" title="3、Dex 加载"></a>3、Dex 加载</h2><p>前面我们提到了 ClassLoader 的代理模式，这种双亲委托的模式，很好的满足了 Android Framework 的系统代码的共享以及应用代码的隔离。</p>
<h4 id="3-1-有几个-ClassLoader-实例"><a href="#3-1-有几个-ClassLoader-实例" class="headerlink" title="3.1 有几个 ClassLoader 实例"></a>3.1 有几个 ClassLoader 实例</h4><p>一般一个应用启动后有几个 ClassLoader 的实例呢？我们使用如下代码来打印一下 ClassLoader 的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        ClassLoader classLoader = getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"[onCreate] classLoader "</span> + i + <span class="string">" : "</span> + classLoader.toString());</span><br><span class="line">            <span class="keyword">while</span> (classLoader.getParent() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                classLoader = classLoader.getParent();</span><br><span class="line">                i++;</span><br><span class="line">                Log.i(TAG,<span class="string">"[onCreate] classLoader "</span> + i + <span class="string">" : "</span> + classLoader.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Log 输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc.solart.nuts I/HomeActivity: [onCreate] classLoader <span class="number">1</span> : dalvik.system.PathClassLoader[DexPathList[[zip file <span class="string">"/data/app/cc.solart.nuts-1.apk"</span>],nativeLibraryDirectories=[/data/app-lib/cc.solart.nuts-<span class="number">1</span>, /vendor/lib, /data/cust/lib, /data/datalib, /system/lib]]]</span><br><span class="line">cc.solart.nuts I/HomeActivity: [onCreate] classLoader <span class="number">2</span> : java.lang.BootClassLoader@<span class="number">41</span>a0c360</span><br></pre></td></tr></table></figure>
<p>可以看到有两个 ClassLoader 的实例输出，一个<code>PathClassLoader</code>，应用启动时创建的，用于加载 apk 中的类，另一个是<code>BootClassLoader</code>，系统启动时创建的，用于加载系统相关的类。</p>
<p>其实看到这里我们可以看出，任何运行的Android应用至少包含有两个 ClassLoader，每个应用中的<code>PathClassLoader</code>拥有同一个<code>parent</code>即是<code>BootClassLoader</code>，这样就保证了<code>系统代码共享以及应用代码隔离</code>，如下图。</p>
<p><img src="/images/classloader.png" alt="classloader"></p>
<p>额外提一下的是，由于系统代码是全局共享的，那么这就产生了一个问题，那就是给了开发者Hook系统代码的机会，所以系统安全性是一个很大的考验，不知道Google是如何考量这个问题的，当然正因为这种机会的存在才给了插件化发展的契机。假设这样一个场景：两个应用都使用了Hook的机制，那么有可能导致一方Hook失效，所以一般在使用Hook后的服务时，一般要去做环境检测，看是否需要重新注入。这就属于Hook框架的博弈了。</p>
<h4 id="3-2-插件化-Dex-加载策略"><a href="#3-2-插件化-Dex-加载策略" class="headerlink" title="3.2 插件化 Dex 加载策略"></a>3.2 插件化 Dex 加载策略</h4><p>我们可以借鉴这种思路应用到插件化的框架中，根据不同的出发点，通常插件化的 Dex 加载策略有两种：</p>
<ul>
<li>可以对每一个插件分配一个<code>ClassLoader</code>分别加载<code>.dex</code>(这是目前最常见的方式)</li>
<li>也可以动态得把插件<code>.dex</code>加载到当前运行环境的<code>Classloader</code>中</li>
</ul>
<p><strong>我们先来看多 ClassLoader 加载的方案</strong>，多 ClassLoader 的方案，还可以细分为两种：一是每个自定义 ClassLoader 的 parent 为当前宿主应用的 ClassLoader 即是 PathClassLoader，这种方案将宿主视为运行环境，插件需依赖宿主运行，插件之间互相隔离，如下图： </p>
<p><img src="/images/pluginclassloader_1.png" alt="pluginclassloader"></p>
<p>一是每个自定义 ClassLoader 的 parent 为 BootClassLoader，这种方案类似原生应用隔离的方案，宿主与插件、插件与插件互相独立，如下图：</p>
<p><img src="/images/pluginclassloader_2.png" alt="pluginclassloader2"></p>
<p>多 ClassLoader 的难度在于 Hook 系统服务以及兼容性适配等工作，本身 ClassLoader 的代码量并不大。</p>
<p><strong>我们再来看单ClassLoader方案</strong>，这种方案是委托给应用的PathClassLoader加载<code>.dex</code>，宿主与插件共享同一个 ClassLoader。</p>
<p>那怎么让 PathClassLoader 帮忙加载 dex 呢，我们在上面分析 BaseDexClassLoader 时，BaseDexClassLoader 在构造时生创建一个<code>DexPathList</code>，而<code>DexPathList</code>内部有一个叫做<code>dexElements</code>数组，我们要做的就是将 dex 文件插入到这个<code>dexElements</code>数组中，在 PathClassLoader 中查找类时，就会遍历这个数组中 DexFile 的信息，完成插件类的加载。</p>
<p>来看看 BaseDexClassLoader 中<code>findClass</code>的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        <span class="comment">//通过DexPathList查找类</span></span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过 <code>DexPathList</code> 完成查找Class，它的 <code>findClass</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里就验证了我们将 dex 文件插入到<code>dexElements</code>数组中这个结论的可行性，接下的工作就是通过反射注入 dex 信息，这里就不在细说了。</p>
<p>回想一下单 ClassLoader 的方案，有没有觉得似曾相识？想必大家对<code>MultiDex</code>并不陌生吧，而这种单 ClassLoader 的方案与<code>MultiDex</code>方案如出一辙。所以这种方案实现起来代码量比较小(参照 MultiDex )，难度相对不大。再扯远一点，微信 Android 团队开源的热修复框架 <a href="https://github.com/tencent/tinker" target="_blank" rel="external">Tinker</a> 中也采用了类似的方式去处理，有兴趣的话可以去读读 <a href="https://github.com/tencent/tinker/blob/master/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java" target="_blank" rel="external">SystemClassLoaderAdder</a> 的代码。</p>
<h4 id="3-3-Dex-加载策略的优劣"><a href="#3-3-Dex-加载策略的优劣" class="headerlink" title="3.3 Dex 加载策略的优劣"></a>3.3 Dex 加载策略的优劣</h4><table>
<thead>
<tr>
<th>方案</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>多ClassLoader</td>
<td>隔离性较好，热更新不必重启进程</td>
<td>存在多个相同的类包，加载 dex 文件大，实现交为复杂</td>
</tr>
<tr>
<td>单ClassLoader</td>
<td>实现相对简单，dex 文件可以做到比较小（毕竟没有重复类库）</td>
<td>隔离性弱（需要避免不同 dex 文件引用类库冲突），热更新需重启进程</td>
</tr>
</tbody>
</table>
<p>在不同的出发点上，优势劣势各有不同，对于 Android 系统来说，程序间的隔离性显然要比其他因素重要的多，系统采用这种应用层隔离的方案是鸡蛋落在鸡窝里—刚刚好。在插件化框架中，多 ClassLoader 也是比较常见的一种方案，在多数情况下，多 ClassLoader 的方案要优于单一 ClassLoader。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/25/va_hook/" class="prev">上一篇</a><a href="/2016/10/30/install_apk/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div class="copyright"><p>© 2015 - 2018 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>