<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TurboRecyclerViewHelper之实现RecyclerView的功能扩展 · Solartisan</title><meta name="description" content="TurboRecyclerViewHelper之实现RecyclerView的功能扩展 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">TurboRecyclerViewHelper之实现RecyclerView的功能扩展</h1><div class="post-info">Jun 1, 2016</div><div class="post-content"><p>自从使用了<code>RecyclerView</code>再也回不去了，什么ListView、GridView统统让他们退休了。必须安利起来，用了才能体会它的神奇！</p>
<p>根据使用<code>RecyclerView</code>以来，拓展的一些功能及对<code>RecyclerView.Adapter</code>的封装，想在这里跟大家分享一些经验，还望指正。</p>
<h1 id="1-功能介绍"><a href="#1-功能介绍" class="headerlink" title="1. 功能介绍"></a>1. 功能介绍</h1><p>基于对<code>RecyclerView</code>在使用过程中的一些痛点写了这个开源项目 <a href="https://github.com/Solartisan/TurboRecyclerViewHelper" target="_blank" rel="external">TurboRecyclerViewHelper</a> 。功能点详见README。</p>
<img src="/images/turbo_simple.gif">
<p>本次主要介绍针对<code>TurboRecyclerView</code>上拉/左滑的功能的实现及思路。</p>
<p>下面直接进入正题…</p>
<a id="more"></a>
<h1 id="2-状态分析"><a href="#2-状态分析" class="headerlink" title="2. 状态分析"></a>2. 状态分析</h1><p>以上拉加载的过程作为本次分享的一个栗子(左滑同理)。状态如下图：</p>
<img src="/images/turbo_state_analysis.png">
<p>我们所关心的是RecyclerView滑动到底部的状态，这个状态下是我们需要处理的<code>临界状态</code>。</p>
<p>下文中出现的代码均为精简后的代码片段，本文重在介绍思路，所涉及的知识点假设您已经掌握，故不再展开赘述。</p>
<h1 id="3-临界状态的限制条件"><a href="#3-临界状态的限制条件" class="headerlink" title="3. 临界状态的限制条件"></a>3. 临界状态的限制条件</h1><p>废话不多说直接看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mLoadEnabled || canScrollEnd() || mIsLoading || isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们从两个方面来分析可以开始处理Touch事件的条件：</p>
<h2 id="3-1-客观条件"><a href="#3-1-客观条件" class="headerlink" title="3.1 客观条件"></a>3.1 客观条件</h2><p>所谓客观条件即是RecyclerView滑动到底部的这个状态的物理状态，体现在代码上就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canScrollEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//判断在纵向是否还能向上滑动</span></span><br><span class="line">   <span class="keyword">return</span> ViewCompat.canScrollVertically(<span class="keyword">this</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了简化只判断了纵向是否可以向下滑动，实际代码中这里是判断条件为<code>ViewCompat.canScrollVertically(this, 1) || ViewCompat.canScrollHorizontally(this, 1)</code></p>
<p>这个条件返回值如果是false，则代表我们可以从这个临界状态开始处理Touch事件，否则不处理。</p>
<h2 id="3-2-逻辑条件（主观条件）"><a href="#3-2-逻辑条件（主观条件）" class="headerlink" title="3.2 逻辑条件（主观条件）"></a>3.2 逻辑条件（主观条件）</h2><p>逻辑条件（或者称为主观条件）是设计控件本身所考虑的限制条件。</p>
<p>判断条件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否允许上拉 || 是否正处于刷新状态 || 是否处理空状态</span></span><br><span class="line"><span class="keyword">if</span> (!mLoadEnabled || mIsLoading || isEmpty())</span><br></pre></td></tr></table></figure></p>
<p>在以上条件下我们认为是控件本身应处于不可上拉的状态，我们不做处理。</p>
<h1 id="4-Touch事件的处理"><a href="#4-Touch事件的处理" class="headerlink" title="4. Touch事件的处理"></a>4. Touch事件的处理</h1><p>在同时满足客观条件和逻辑条件下，我们就可以开始处理上拉的效果。</p>
<h2 id="4-1-记录初始值"><a href="#4-1-记录初始值" class="headerlink" title="4.1 记录初始值"></a>4.1 记录初始值</h2><p>我们需要在<code>MotionEvent.ACTION_DOWN</code> <code>MotionEvent.ACTION_POINTER_DOWN</code>时记录初始值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mInitialMotionX = getMotionEventX(e, actionIndex);</span><br><span class="line">mInitialMotionY = getMotionEventY(e, actionIndex);</span><br></pre></td></tr></table></figure></p>
<h2 id="4-2-判断滑动是否符合预期值"><a href="#4-2-判断滑动是否符合预期值" class="headerlink" title="4.2 判断滑动是否符合预期值"></a>4.2 判断滑动是否符合预期值</h2><p>在<code>MotionEvent.ACTION_MOVE</code>时判断是否是上拉的状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LayoutManager中提供的判断是否纵向可以滑动的方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canScrollVertically = getLayoutManager().canScrollVertically();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> y = getMotionEventY(e, index);</span><br><span class="line"><span class="keyword">int</span> deltaY = y - mInitialMotionY;</span><br><span class="line"><span class="keyword">if</span> (canScrollVertically &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop &amp;&amp; deltaY &lt; <span class="number">0</span>) &#123; ... <span class="comment">//处理上拉效果&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>记录当前Y值，且判断是否手指在上滑状态。</p>
<h2 id="4-3-实现上拉效果"><a href="#4-3-实现上拉效果" class="headerlink" title="4.3 实现上拉效果"></a>4.3 实现上拉效果</h2><p>在自定义控件中，实现上拉效果有多种途径，例如大家常用的利用<code>Scroller</code>配合<code>scrollTo</code>来实现滑动，但是在RecyclerView的实现中并不支持这种方式。这个方案Close!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"RecyclerView does not support scrolling to an absolute position. "</span></span><br><span class="line">            + <span class="string">"Use scrollToPosition instead"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里采用<code>setTranslationY</code>来实现上拉效果，根据手指移动的距离计算出移动距离来改变RecyclerView的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">float</span> targetEnd = -dampAxis(deltaY); <span class="comment">//阻尼值的计算</span></span><br><span class="line">setTranslationY(targetEnd);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//消费掉此事件</span></span><br></pre></td></tr></table></figure></p>
<p>到这里上拉的效果已经实现完毕。</p>
<h2 id="4-4-复位及刷新"><a href="#4-4-复位及刷新" class="headerlink" title="4.4 复位及刷新"></a>4.4 复位及刷新</h2><p>距离成功只差一点点。<br>在用户手指松开以后，我们要考虑做两件事：RecyclerView的复位及是否可以处于刷新状态。<br>针对复位操作，我们只需要逆向<code>setTranslationY</code>值即可。这里我们采用属性动画来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateOffsetToEnd</span><span class="params">(<span class="keyword">final</span> String propertyName, <span class="keyword">final</span> Interpolator interpolator, <span class="keyword">float</span>... value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mResetAnimator == <span class="keyword">null</span>) &#123;</span><br><span class="line">           mResetAnimator = <span class="keyword">new</span> ObjectAnimator();</span><br><span class="line">           mResetAnimator.setTarget(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mResetAnimator.cancel();</span><br><span class="line">       mResetAnimator.setPropertyName(propertyName);</span><br><span class="line">       mResetAnimator.setFloatValues(value);</span><br><span class="line">       mResetAnimator.setInterpolator(interpolator);</span><br><span class="line">       mResetAnimator.start();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">...</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(canScrollVertically)</span><br><span class="line">	animateOffsetToEnd(<span class="string">"translationY"</span>, mInterpolator, <span class="number">0f</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>对于刷新我们要做的事情也比较简单，判断当前移动距离达到阈值后，回调监听事件并显示LOAING_VIEW。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Log.i(TAG, <span class="string">"refreshing..."</span>);</span><br><span class="line">mIsLoading = <span class="keyword">true</span>;</span><br><span class="line">dispatchOnLoadingMoreListeners();</span><br><span class="line">smoothScrollToPosition(mLastVisibleItemPosition + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>刷新完毕后，记得通知TurboRecyclerView更新状态哦！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mTurboRecyclerView.addOnLoadingMoreListener(<span class="keyword">new</span> OnLoadMoreListener() &#123;</span><br><span class="line">       <span class="annotation">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="annotation">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   mRecyclerView.loadMoreComplete(Arrays.asList(sCheeseStrings));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, <span class="number">2000</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>至此整个上拉到复位刷新的过程完成。<br>完整代码详见 <a href="https://github.com/Solartisan/TurboRecyclerViewHelper/blob/master/turbo-recyclerview-helper/src/main/java/cc/solart/turbo/TurboRecyclerView.java" target="_blank" rel="external">TurboRecyclerView.java</a></p>
<p>希望我的分享能让您能有所收获。也欢迎支持一下<a href="https://github.com/Solartisan/TurboRecyclerViewHelper" target="_blank" rel="external">这个项目</a>~ 持续维护~</p>
<p>下次准备介绍一下对<code>RecyclerView.Adapter</code>的封装，还请关注！😊</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/18/turbo-recyclerview-helper-2/" class="prev">上一篇</a><a href="/2016/05/14/code-specification/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div data-thread-key="2016/06/01/turbo-recyclerview-helper-1/" data-title="TurboRecyclerViewHelper之实现RecyclerView的功能扩展" data-url="http://solart.cc/2016/06/01/turbo-recyclerview-helper-1/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"solart"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script><div class="copyright"><p>© 2015 - 2017 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>