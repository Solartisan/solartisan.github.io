<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android插件化学习 · Solartisan</title><meta name="description" content="Android插件化学习 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android插件化学习</h1><div class="post-info">Jul 11, 2016</div><div class="post-content"><p>插件化技术（也叫动态加载技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来给应用瘦身，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。对于业务迭代较快的公司，可以减少发包次数而且有很好的覆盖度。</p>
<p>以下为这段时间学习插件化的一些笔记或摘要及自己的一些理解。</p>
<a id="more"></a>
<h2 id="1、Java类加载器"><a href="#1、Java类加载器" class="headerlink" title="1、Java类加载器"></a>1、Java类加载器</h2><p>提到Android插件化，一个基础的知识点就是java的类加载机制。</p>
<h4 id="类加载器的树状组织结构"><a href="#类加载器的树状组织结构" class="headerlink" title="类加载器的树状组织结构"></a>类加载器的树状组织结构</h4><p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p>
<ul>
<li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 <code>java.lang.ClassLoader</code>。</li>
</ul>
<ul>
<li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。</li>
</ul>
<h4 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h4><p><code>类加载器</code>在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<h4 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h4><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 <code>defineClass</code>来实现的；而启动类的加载过程是通过调用 <code>loadClass</code>来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。</p>
<h2 id="2、动态代理"><a href="#2、动态代理" class="headerlink" title="2、动态代理"></a>2、动态代理</h2><p>代理及动态代理在插件化的技术中也起到了至关重要的作用。</p>
<h4 id="Java-实现动态代理"><a href="#Java-实现动态代理" class="headerlink" title="Java 实现动态代理"></a>Java 实现动态代理</h4><p>Java实现动态代理的大致步骤如下：</p>
<ul>
<li>定义一个委托类和公共接口。</li>
</ul>
<ul>
<li>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类。</li>
</ul>
<ul>
<li>生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li>
</ul>
<p>Java 实现动态代理主要涉及以下几个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 <code>DynamicProxyClass extends Proxy</code>。</li>
</ul>
<ul>
<li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。</li>
</ul>
<p>Proxy 类主要方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建代理对象  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么）。这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//源代码中关键代码为下面注释的代码，将其拆解为三个过程方便阅读</span></span><br><span class="line">    <span class="comment">//return getProxyClass(loader, interfaces)</span></span><br><span class="line">    <span class="comment">//                .getConstructor(InvocationHandler.class)</span></span><br><span class="line">    <span class="comment">//                .newInstance(invocationHandler);</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1. 根据类加载器和接口创建代理类</span></span><br><span class="line">    Class clazz = Proxy.getProxyClass(loader, interfaces); </span><br><span class="line">    <span class="comment">//2. 获得代理类的带参数的构造函数</span></span><br><span class="line">    Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;);</span><br><span class="line">    <span class="comment">//3. 创建代理对象，并制定调用处理器实例为参数传入</span></span><br><span class="line">    Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123;handler&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、Android动态加载技术三个关键问题"><a href="#3、Android动态加载技术三个关键问题" class="headerlink" title="3、Android动态加载技术三个关键问题"></a>3、Android动态加载技术三个关键问题</h2><p>不同的插件化方案各有各的特色，但是它们都必须要解决三个基础性问题：ClassLoader的管理、生命周期的管理以及资源的访问。 </p>
<h4 id="ClassLoader的管理"><a href="#ClassLoader的管理" class="headerlink" title="ClassLoader的管理"></a>ClassLoader的管理</h4><p>针对ClassLoader的管理有两种方案：</p>
<ul>
<li>可以对每一个插件分配一个<code>ClassLoader</code>(这是目前最常见的一种方式)</li>
<li>也可以动态得把插件加载到当前运行环境的classloader中</li>
</ul>
<h4 id="生命周期的管理"><a href="#生命周期的管理" class="headerlink" title="生命周期的管理"></a>生命周期的管理</h4><p>通过ClassLoader加载了外部dex，但是通过这种方式却不能启动插件中的应该具有生命周期的组件，例如：Activity。</p>
<p>Activity等组件是需要在<code>AndroidManifest</code>中注册后才能以标准<code>Intent</code>的方式启动的，通过ClassLoader加载并实例化的Activity实例只是一个普通的Java对象，能调用对象的方法，但是它没有生命周期，<code>Activity</code>、<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理，所以在Android系统上，仅仅完成动态类加载是不够的，我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期。所以摆在眼前的一个困难就是如何让组件获得生命活力。</p>
<p>针对组件生命周期的管理，大约有以下两(三)种方案：</p>
<ul>
<li><p>通过代理模式管理插件生命周期（有同学评价为牵线木偶式管理）</p>
<ul>
<li>在代理组件中通过反射调用插件相应的生命周期（性能开销较大，不推荐使用）</li>
<li>将生命周期抽象为接口，在代理组件中调用生命周期</li>
</ul>
</li>
<li><p>通过Hook机制管理插件生命周期（瞒天过海、偷梁换柱、借尸还魂，指的就是这种方式）</p>
<p><code>DroidPlugin</code>及天才少年lody开源的<a href="https://github.com/asLody/VirtualApp" target="_blank" rel="external">VirtualApp</a>中均通过动态代理Hook后的系统Binder服务，从而巧妙的掌控了上帝视角。不同的是<code>VirtualApp</code>基于注解的依赖注入处理Hook，在代码上更清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBinder baseBinder;</span><br><span class="line"><span class="keyword">private</span> Interface mBaseObject;</span><br><span class="line"><span class="keyword">private</span> Interface mProxyObject;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.baseBinder = queryBaseBinder();</span><br><span class="line">	<span class="keyword">if</span> (baseBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.mBaseObject = createInterface(baseBinder);</span><br><span class="line">		mProxyObject = (Interface) Proxy.newProxyInstance(mBaseObject.getClass().getClassLoader(),</span><br><span class="line">				mBaseObject.getClass().getInterfaces(), <span class="keyword">new</span> HookHandler());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getProxyObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hook机制不但解决了生命周期的问题，而且使得插件能够<strong>无缝地</strong>使用这些系统服务，对于插件apk的开发就跟平常开发app并无区别，不用关心一些规则的限制。</p>
</li>
</ul>
<h4 id="资源的访问"><a href="#资源的访问" class="headerlink" title="资源的访问"></a>资源的访问</h4><p>对于资源的访问，我们来追寻一下源码中是通过什么方式来获取资源的。</p>
<p>我们知道<code>Activity</code>是继承自<code>Context</code>，而<code>Context</code>唯一实现类是<code>ContxtImpl</code>，Activity中有一个叫<code>mBase</code>的成员变量，它的类型就是<code>ContextImpl</code>。注意到Context中有如下两个抽象方法，看起来是和资源有关 的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中，也就是说，只要实现这两个方法，就可以解决资源问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Return an AssetManager instance for your application's package. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AssetManager <span class="title">getAssets</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Return a Resources instance for your application's package. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Resources <span class="title">getResources</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>查看系统的<a href="https://developer.android.com/reference/android/content/res/Resources.html" target="_blank" rel="external"><code>Resources</code></a>源码，我们发现这个类主要做了两件事，首当其冲的当然是访问资源，另外一件就是管理资源配置信息。对于资源的动态加载来说，我们关心的是它如何做第一件事的。我们发现，<code>Resources</code>对资源的访问，全部代理给了另一个重要的对象<code>AssetManager</code>。那么问题转化成了，<a href="https://developer.android.com/reference/android/content/res/AssetManager.html" target="_blank" rel="external"><code>AssetManager</code></a>是如何做到对资源的访问的。<code>Resources</code>类在它的构造函数里对<code>AssetManager</code>做了一些重要的初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a new Resources object with CompatibilityInfo.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> assets Previously created AssetManager. </span><br><span class="line"> * <span class="doctag">@param</span> metrics Current display metrics to consider when </span><br><span class="line"> *                selecting/computing resource values.</span><br><span class="line"> * <span class="doctag">@param</span> config Desired device configuration to consider when </span><br><span class="line"> *               selecting/computing resource values (optional).</span><br><span class="line"> * <span class="doctag">@param</span> compatInfo this resource's compatibility info. Must not be null.</span><br><span class="line"> * <span class="doctag">@param</span> token The Activity token for determining stack affiliation. Usually null.</span><br><span class="line"> * <span class="doctag">@hide</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Resources</span><span class="params">(AssetManager assets, DisplayMetrics metrics, Configuration config,</span><br><span class="line">        CompatibilityInfo compatInfo, IBinder token)</span> </span>&#123;</span><br><span class="line">    mAssets = assets;</span><br><span class="line">    mMetrics.setToDefaults();</span><br><span class="line">    <span class="keyword">if</span> (compatInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCompatibilityInfo = compatInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    mToken = <span class="keyword">new</span> WeakReference&lt;IBinder&gt;(token);</span><br><span class="line">    updateConfiguration(config, metrics);</span><br><span class="line">    assets.ensureStringBlocks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的重点就是调用了<code>AssetManager</code>对象的ensureStringBlocks()函数，这个函数的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureStringBlocks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mStringBlocks == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (mStringBlocks == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 makeStringBlocks(sSystem.mStringBlocks);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>先判断<code>mStringBlocks</code>变量是否为空，如果不为空的话，表示需要被初始化，于是调用makeStringBlocks函数初始化mStringBlocks:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">makeStringBlocks</span><span class="params">(StringBlock[] seed)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> seedNum = (seed != <span class="keyword">null</span>) ? seed.length : <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> num = getStringBlockCount();</span><br><span class="line">     mStringBlocks = <span class="keyword">new</span> StringBlock[num];</span><br><span class="line">     <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"Making string blocks for "</span> + <span class="keyword">this</span></span><br><span class="line">             + <span class="string">": "</span> + num);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i &lt; seedNum) &#123;</span><br><span class="line">             mStringBlocks[i] = seed[i];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             mStringBlocks[i] = <span class="keyword">new</span> StringBlock(getNativeStringBlock(i), <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mStringBlocks对象是一个<code>StringBlock</code>数组，这个类被标记为<code>@hide</code>，表示应用层根本不需要关心它的存在。那么它是做什么用的呢，它就是<code>AssetManager</code>能够访问资源的奥秘所在，<code>AssetManager</code>所有访问资源的函数，例如getResourceTextArray()，都最终通过StringBlock再代理到native进行访问的。看到这里，依然没有任何看到能够指示为什么开发者可以访问自己应用的资源，那么我们再往前看一点，看看传入<code>Resources</code>的构造函数之前，asset参数是不是被“做过手脚”。我们现在来看一下<code>Resources</code>被实例化的地方，经过翻阅代码发现，在<code>ResourceManager</code>的<code>getTopLevelResources</code>函数被实例化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span><br><span class="line">   * Creates the top level Resources for applications with the given compatibility info.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> resDir the resource directory.</span><br><span class="line">   * <span class="doctag">@param</span> overlayDirs the resource overlay directories.</span><br><span class="line">   * <span class="doctag">@param</span> libDirs the shared library resource dirs this app references.</span><br><span class="line">   * <span class="doctag">@param</span> compatInfo the compability info. Must not be null.</span><br><span class="line">   * <span class="doctag">@param</span> token the application token for determining stack bounds.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resources <span class="title">getTopLevelResources</span><span class="params">(String resDir, String[] splitResDirs,</span><br><span class="line">          String[] overlayDirs, String[] libDirs, <span class="keyword">int</span> displayId,</span><br><span class="line">          Configuration overrideConfiguration, CompatibilityInfo compatInfo, IBinder token)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">       Resources r;</span><br><span class="line">...</span><br><span class="line">       AssetManager assets = <span class="keyword">new</span> AssetManager();</span><br><span class="line">      <span class="comment">// resDir can be null if the 'android' package is creating a new Resources object.</span></span><br><span class="line">      <span class="comment">// This is fine, since each AssetManager automatically loads the 'android' package</span></span><br><span class="line">      <span class="comment">// already.</span></span><br><span class="line">      <span class="keyword">if</span> (resDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (assets.addAssetPath(resDir) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      r = <span class="keyword">new</span> Resources(assets, dm, config, compatInfo, token);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码有点多，截取最重要的部分，那就是系统通过调用<code>AssetManager</code>的<code>addAssetPath</code>函数，将需要加载的资源路径加了进去。<code>addAssetPath</code>函数返回一个int类型，它指示了每个被添加的资源路径在native层一个数组中的位置，这个数组保存了系统资源路径(framework-res.apk)，和应用自己添加的所有的资源路径。再回过头看makeStringBlocks函数，就豁然开朗了：</p>
<ol>
<li>makeStringBlocks函数的参数也是一个StringBlock数组，它表示系统资源，首先它调用getStringBlockCount函数得到当前应用所有要加载的资源路径数量。</li>
<li>然后进入循环，如果属于系统资源，就直接用传入参数seed中的对象来赋值。</li>
<li>如果是应用自己的资源，就实例化一个新的StringBlock对象来赋值。并在StringBlock的构造函数中调用getNativeStringBlock函数来获取一个native层的对象指针，这个指针被java层StringBlock对象用来调用native函数，最终达到访问资源的目的。</li>
</ol>
<blockquote>
<p>插件化技术比较受到国内开发者青睐，国外则更多的热衷于Facebook开源的<a href="https://github.com/facebook/react-native" target="_blank" rel="external">react native</a>技术，出于快速迭代的目的其实还有另一种做法，在早几年已经有行业内一线公司采用，使用本地H5配合<code>WebView</code>达到快速迭代，H5代码则通过线上打包更新(全量或增量)的方式，将其最新版本更新至本地加载，这一方面解决了公司对业务快速迭代的需求，另一方面也缓解了线上H5对网络环境的依赖，也算是一种成熟可用的折中方案。</p>
</blockquote>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">深入探讨Java 类加载器</a></li>
</ul>
<ul>
<li><a href="http://www.jianshu.com/p/6f6bb2f0ece9" target="_blank" rel="external">代理模式及Java实现动态代理</a></li>
</ul>
<ul>
<li><a href="https://blog.tingyun.com/web/article/detail/166" target="_blank" rel="external">Android动态加载技术三个关键问题详解</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTcwNTE0NA==&amp;mid=400217391&amp;idx=1&amp;sn=86181541ce0164156dfab135ed99bb5c&amp;scene=0&amp;key=b410d3164f5f798e61a5d4afb759fa38371c8b119384c6163a30c28163b4d4d5f59399f2400800ec842f1d0e0ffb84af&amp;ascene=0&amp;uin=MjExMjQ&amp;pass_ticket=Nt5Jaa28jjFxcQO9o%2BvQiXX%2B0iXG5DlZlHNW97Fk1Ew%3D" target="_blank" rel="external">携程Android App插件化和动态加载实践</a></li>
<li><a href="http://mogu.io/117-117" target="_blank" rel="external">蘑菇街 App 的组件化之路(一)</a></li>
<li><a href="http://mogu.io/119-119" target="_blank" rel="external">蘑菇街 App 的组件化之路(二)</a></li>
<li><a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="external">插件化原理解析—Activity生命周期管理</a></li>
<li><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="external">插件化原理解析—Hook机制之Binder Hook</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/08/20/launch_app/" class="prev">上一篇</a><a href="/2016/06/18/turbo-recyclerview-helper-2/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div data-thread-key="2016/07/11/learn_plugin/" data-title="Android插件化学习" data-url="http://solart.cc/2016/07/11/learn_plugin/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"solart"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>