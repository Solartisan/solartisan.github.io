<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 也许是最贴近京东首页体验的嵌套滑动吸顶效果 · Solartisan</title><meta name="description" content="也许是最贴近京东首页体验的嵌套滑动吸顶效果 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">也许是最贴近京东首页体验的嵌套滑动吸顶效果</h1><div class="post-info">Jul 17, 2020</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">blue</a></p>
<p>v 信号: <code>Mojitok8275</code></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p>吸顶效果是各家 App 或多或少都会用的一个交互，这种交互也常见于 PC、H5，可以说是一种通用性很强的前端交互体验，相比较来说京东首页的嵌套滑动吸顶效果是各个类似效果中体验比较好的一个，因为在嵌套布局中滑动连贯性处理得非常好，今天我们就来实现同样的交互效果。</p>
<h3 id="这篇文章我会讲些什么"><a href="#这篇文章我会讲些什么" class="headerlink" title="这篇文章我会讲些什么"></a>这篇文章我会讲些什么</h3><ul>
<li>对于吸附效果实现的思路</li>
<li>3 个版本的 NestedScrollingParent、NestedScrollingChild 简单介绍</li>
<li>嵌套组件滑动连贯性（一致性）的处理（事件分发、Fling 等）</li>
<li>交互的优化问题</li>
</ul>
<p>首先，先看一下我们实现的效果图：</p>
<p><img src="/images/nested_live.gif" width="220"></p>
<p>这里只介绍我们实现过程中的思路，以及部分代码，源码请查看 <a href="https://github.com/solartcc/NestedCeilingEffect" target="_blank" rel="external">NestedCeilingEffect</a>，欢迎建议、Issues、Star</p>
<h2 id="1、实现滑动吸顶效果的简单分析"><a href="#1、实现滑动吸顶效果的简单分析" class="headerlink" title="1、实现滑动吸顶效果的简单分析"></a>1、实现滑动吸顶效果的简单分析</h2><p>对于吸顶效果，首先我们要先创造出 <code>“顶”</code> 来，那么如何创造 <code>“顶”</code> 呢？常见的实现方式有很多，比如：</p>
<ul>
<li>通过两个相同的顶部控件显示或隐藏来实现</li>
<li>通过动态 layout 顶部控件来实现</li>
<li>通过重写 ItemDecoration 来实现</li>
<li>通过 CoordinatorLayout 协调子布局来实现</li>
</ul>
<p>这些方式或多或少在某些方面有一些场景上的限制，这次我们采用另外一种方式来实现 <code>“顶”</code> 的效果，这里先卖一个关子。</p>
<a id="more"></a>
<p>如果我们已经成功的创造出 <code>“顶”</code> 来，那么接下来就是处理好控件的滑动效果，应该就可以实现我们想要的效果了，说来简单，我们不妨通过 <code>Layout Inspector</code> 工具来看一下相关 App 的布局，帮助我们整理思路，我们查看京东首页的布局，发现的确是采用两层 <code>RecyclerView</code> 嵌套来实现的，所以我们同样可以构建这样一个布局结构：</p>
<p><img src="/images/nested_layout.png" alt="NestedLayout"></p>
<p>那么接下来我们就来实现它。</p>
<h2 id="2、创造-“顶”-的效果"><a href="#2、创造-“顶”-的效果" class="headerlink" title="2、创造 “顶” 的效果"></a>2、创造 <code>“顶”</code> 的效果</h2><p>我们上面提到了几种构建 <code>“顶”</code> 的方式，我们这里采用固定高度的方式来实现。在我们的布局中整个蓝色区域其实就是最后一个 <code>item</code> ，那么我们只需要对最后整个 <code>item</code> 固定高度为父布局的高度即可，对于 <code>NestedParentRecyclerView</code> 来说它滑动到底部时不能再向上滑动了，而此时蓝色部分正好充满父布局，从而实现了 <code>“顶”</code> 的效果。</p>
<p>相比较来说，我们确定最后一个 <code>item</code> 高度的时机选择在 <code>onChildAttachedToWindow</code> 比较合适。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedParentRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildAttachedToWindow</span><span class="params">(@NonNull View child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTargetPosition(child)) &#123;</span><br><span class="line">            ViewGroup.LayoutParams lp = child.getLayoutParams();</span><br><span class="line">            lp.height = getMeasuredHeight();</span><br><span class="line">            child.setLayoutParams(lp);</span><br><span class="line">            mContentView = (ViewGroup) child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildDetachedFromWindow</span><span class="params">(@NonNull View child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTargetPosition(child)) &#123;</span><br><span class="line">            mContentView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTargetPosition</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutManager != <span class="keyword">null</span> &amp;&amp; mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> position = mLayoutManager.getPosition(child);</span><br><span class="line">            <span class="keyword">return</span> position + <span class="number">1</span> == mAdapter.getItemCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>RecyclerView</code> 本身的复用回收效果所以我们在 <code>onChildDetachedFromWindow</code> 时要将引用置空。</p>
<h2 id="3、嵌套布局滑动连贯性的处理"><a href="#3、嵌套布局滑动连贯性的处理" class="headerlink" title="3、嵌套布局滑动连贯性的处理"></a>3、嵌套布局滑动连贯性的处理</h2><p>在开始介绍滑动连贯性的处理之前，我们先简单介绍一下 <code>NestedScrollingParent</code>、<code>NestedScrollingChild</code> 的使用，随着不断的发展这套 API 已经有了<code>三</code>个版本，目前主要用 <code>2和3</code> </p>
<table>
<thead>
<tr>
<th>NestedScrollingChild</th>
<th>NestedScrollingParent</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>startNestedScroll</td>
<td>onStartNestedScroll</td>
<td style="text-align:left"><code>child</code> 的调用会触发 <code>parent</code> 回调， <code>onStartNestedScroll</code> 返回值决定了后续嵌套滑动事件是否传递给 <code>parent</code> 处理</td>
</tr>
<tr>
<td></td>
<td>onNestedScrollAccepted</td>
<td style="text-align:left">如果 <code>onStartNestedScroll</code> 返回 true，则回调此方法</td>
</tr>
<tr>
<td>dispatchNestedPreScroll</td>
<td>onNestedPreScroll</td>
<td style="text-align:left"><code>child</code> 滑动前触发 <code>parent</code> 回调，<code>parent</code> 根据自身情况决定是否要滑动</td>
</tr>
<tr>
<td>dispatchNestedScroll</td>
<td>onNestedScroll</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>dispatchNestedPreFling</td>
<td>onNestedPreFling</td>
<td style="text-align:left"><code>child</code> Fling 前触发 <code>parent</code> 回调</td>
</tr>
<tr>
<td>dispatchNestedFling</td>
<td>onNestedFling</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>stopNestedScroll</td>
<td>onStopNestedScroll</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td>getNestedScrollAxes</td>
<td style="text-align:left">获得滑动方向，此方法为主动调用的方法</td>
</tr>
</tbody>
</table>
<p>而调用关系其实并不复杂，所有的调用都跟 <code>Touch</code> 事件脱离不开，这里附上一张流程图，方便大家理解</p>
<p><img src="/images/nested_scrolling.png" alt="NestedScrolling"></p>
<h4 id="3-1-子布局的滑动传递处理"><a href="#3-1-子布局的滑动传递处理" class="headerlink" title="3.1 子布局的滑动传递处理"></a>3.1 子布局的滑动传递处理</h4><p>本身 <code>RecyclerView</code> 已经实现了 <code>NestedScrollingChild</code> ，而我们选择外层布局也使用了 <code>RecyclerView</code> 为了能够处理子布局的嵌套滑动时间，我们让 <code>NestedParentRecyclerView</code> 实现 <code>NestedScrollingParent3</code> 以及 <code>NestedScrollingParent2</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedParentRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> <span class="keyword">implements</span> <span class="title">NestedScrollingParent3</span>, <span class="title">NestedScrollingParent2</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// NestedScrollingParent3</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">                               <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span> type, @NonNull <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">        onNestedScrollInternal(dyUnconsumed, type, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNestedScrollInternal</span><span class="params">(<span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span> type, @Nullable <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldScrollY = computeVerticalScrollOffset();</span><br><span class="line">        scrollBy(<span class="number">0</span>, dyUnconsumed);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> myConsumed = computeVerticalScrollOffset() - oldScrollY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (consumed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            consumed[<span class="number">1</span>] += myConsumed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> myUnconsumed = dyUnconsumed - myConsumed;</span><br><span class="line"></span><br><span class="line">        dispatchNestedScroll(<span class="number">0</span>, myConsumed, <span class="number">0</span>, myUnconsumed, <span class="keyword">null</span>, type, consumed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NestedScrollingParent2</span></span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isParentScroll = dispatchNestedPreScroll(dx, dy, consumed, <span class="keyword">null</span>, type);</span><br><span class="line">        <span class="comment">// 在父嵌套布局没有滑动时，处理此控件是否需要滑动</span></span><br><span class="line">        <span class="keyword">if</span> (!isParentScroll) &#123;</span><br><span class="line">            <span class="comment">// 向上滑动且此控件没有滑动到底部时，需要让此控件继续滑动以保证滑动连贯一致性</span></span><br><span class="line">            <span class="keyword">boolean</span> needKeepScroll = dy &gt; <span class="number">0</span> &amp;&amp; !isScrollEnd();</span><br><span class="line">            <span class="keyword">if</span> (needKeepScroll) &#123;</span><br><span class="line">                scrollBy(<span class="number">0</span>, dy);</span><br><span class="line">                consumed[<span class="number">1</span>] = dy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 其他省略请参看源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过以上的处理， <code>NestedParentRecyclerView</code> 作为父嵌套布局已经能够处理子嵌套布局传递过来的事件，整体连贯性上就比较像一个整体的控件。</p>
<h4 id="3-2-父布局的滑动传递处理"><a href="#3-2-父布局的滑动传递处理" class="headerlink" title="3.2 父布局的滑动传递处理"></a>3.2 父布局的滑动传递处理</h4><p>而对于父布局的滑动传递处理，我们就需要覆写 <code>onTouchEvent</code> 单独处理滑动传递了，我们的目的是让两个控件滑动连贯性更好，所以当父控件已经滑动到底部，需要让子嵌套布局滑动剩余的距离，其实代码也比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedParentRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            mLastY = e.getY();</span><br><span class="line">            mNestedYOffsets = <span class="number">0</span>;</span><br><span class="line">            mVelocityY = <span class="number">0</span>;</span><br><span class="line">            stopScroll();</span><br><span class="line">        &#125;</span><br><span class="line">        RecyclerView child = FindTarget.findChildScrollTarget(mContentView);</span><br><span class="line">        <span class="keyword">boolean</span> handle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此控件已经滑动到底部，需要让子嵌套布局滑动剩余的距离</span></span><br><span class="line">            <span class="comment">// 或者子嵌套布局向下还未到顶部，也需要让子嵌套布局先滑动一段距离</span></span><br><span class="line">            <span class="keyword">int</span> deltaY = (<span class="keyword">int</span>) (mLastY - e.getY());</span><br><span class="line">            <span class="keyword">if</span> (isScrollEnd() || (handle = !isChildScrollTop(child))) &#123;</span><br><span class="line">                child.scrollBy(<span class="number">0</span>, deltaY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastY = e.getY();</span><br><span class="line">        <span class="keyword">return</span> handle || <span class="keyword">super</span>.onTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，除了以上对滑动连贯性的处理还有对于 <code>Fling</code> 连贯性的处理，详细的部分见源码，这里就不在一一展开。</p>
<h2 id="4、准确的状态回调"><a href="#4、准确的状态回调" class="headerlink" title="4、准确的状态回调"></a>4、准确的状态回调</h2><p>通常在触顶或者脱离的时候我们需要处理 UI 的变化，例如触顶时，显示返回 Top 的按钮等，这个时候就需要我们的控件能够提供准确的状态回调，所以这里我们定义一个接口 <code>OnChildAttachStateListener</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnChildAttachStateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 子布局吸附到顶部时回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChildAttachedToTop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 子布局从顶部脱离时回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChildDetachedFromTop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们接下来就要思考如何准确的判断这个状态了， <code>RecyclerView</code> 滑动时判断会不断的触发 <code>onScrolled</code> 的回调，这里监听状态的变化最合适不过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedParentRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsChildAttachedToTop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsChildDetachedFromTop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;OnChildAttachStateListener&gt; mOnChildAttachStateListeners =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOnChildAttachStateListener</span><span class="params">(OnChildAttachStateListener listener)</span> </span>&#123;</span><br><span class="line">        mOnChildAttachStateListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">boolean</span> attached = dy &gt; <span class="number">0</span> &amp;&amp; isScrollEnd();</span><br><span class="line">        <span class="keyword">if</span>(attached &amp;&amp; mIsChildDetachedFromTop) &#123;</span><br><span class="line">            mIsChildAttachedToTop = <span class="keyword">true</span>;</span><br><span class="line">            mIsChildDetachedFromTop = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> listenerCount = mOnChildAttachStateListeners.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listenerCount; i++) &#123;</span><br><span class="line">                OnChildAttachStateListener listener = mOnChildAttachStateListeners.get(i);</span><br><span class="line">                listener.onChildAttachedToTop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> detached = dy &lt; <span class="number">0</span> &amp;&amp; !isScrollEnd();</span><br><span class="line">        <span class="keyword">if</span> (detached &amp;&amp; mIsChildAttachedToTop) &#123;</span><br><span class="line">            RecyclerView child = FindTarget.findChildScrollTarget(mContentView);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span> || isChildScrollTop(child)) &#123;</span><br><span class="line">                mIsChildDetachedFromTop = <span class="keyword">true</span>;</span><br><span class="line">                mIsChildAttachedToTop = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> listenerCount = mOnChildAttachStateListeners.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listenerCount; i++) &#123;</span><br><span class="line">                    OnChildAttachStateListener listener = mOnChildAttachStateListeners.get(i);</span><br><span class="line">                    listener.onChildDetachedFromTop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、其他优化问题"><a href="#5、其他优化问题" class="headerlink" title="5、其他优化问题"></a>5、其他优化问题</h2><h4 id="5-1-临界状态父布局触摸事件分发后再次接管滑动时的跳动问题处理"><a href="#5-1-临界状态父布局触摸事件分发后再次接管滑动时的跳动问题处理" class="headerlink" title="5.1 临界状态父布局触摸事件分发后再次接管滑动时的跳动问题处理"></a>5.1 临界状态父布局触摸事件分发后再次接管滑动时的跳动问题处理</h4><p>为了保证控件的滑动连贯性，我们对滑动事件进行了分发，这个问题出现的原因在于父布局向子布局分发向上滑动的事件后，手指又向下滑动，这是由于事件又回到本身处理时，在 <code>super.onTouchEvent(e)</code> 中 <code>MotionEvent</code> 的坐标与手指出现了偏离，导致了跳帧的现象。所以，我们只需要对 <code>MotionEvent</code> 偏移量进行更新即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedParentRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        RecyclerView child = FindTarget.findChildScrollTarget(mContentView);</span><br><span class="line">        <span class="keyword">boolean</span> handle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isScrollEnd() || (handle = !isChildScrollTop(child))) &#123;</span><br><span class="line">                <span class="keyword">int</span> deltaY = (<span class="keyword">int</span>) (mLastY - e.getY());</span><br><span class="line">                child.scrollBy(<span class="number">0</span>, deltaY);</span><br><span class="line">                <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">                    <span class="comment">// 子嵌套布局向下滑动时，要记录y轴的偏移量</span></span><br><span class="line">                    mNestedYOffsets += deltaY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastY = e.getY();</span><br><span class="line">        <span class="comment">// 更新触摸事件的偏移位置，以保证视图平滑的连贯性</span></span><br><span class="line">        e.offsetLocation(<span class="number">0</span>, mNestedYOffsets);</span><br><span class="line">        <span class="keyword">return</span> handle || <span class="keyword">super</span>.onTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-加速度问题的优化"><a href="#5-2-加速度问题的优化" class="headerlink" title="5.2 加速度问题的优化"></a>5.2 加速度问题的优化</h4><p>为了避免过快加载内容，一定程度上能减少 App 卡顿掉帧，我们同样对于加速度进行了限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FlingHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlingHelper</span><span class="params">(Context context, <span class="keyword">float</span> factor)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mMaxFlingVelocity = (<span class="keyword">int</span>) (ViewConfiguration.get(context).getScaledMaximumFlingVelocity() * factor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 限制加速的最大值 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFlingVelocity</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(-mMaxFlingVelocity, Math.min(velocity, mMaxFlingVelocity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-子布局脱离顶部时的状态恢复"><a href="#5-3-子布局脱离顶部时的状态恢复" class="headerlink" title="5.3 子布局脱离顶部时的状态恢复"></a>5.3 子布局脱离顶部时的状态恢复</h4><p>这个优化点是为了保证众多 Tab 中从顶部脱离时，所有的 Tab 都要回归起始位置，当然这部分需要在状态监听里去处理了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">resetToTop</span><span class="params">()</span> &#123;</span></span><br><span class="line">        recyclerView?.let &#123;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> mLayoutManager</span> = it.layoutManager <span class="keyword">as</span> StaggeredGridLayoutManager</span><br><span class="line">            mLayoutManager.scrollToPositionWithOffset(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-其他已知问题"><a href="#5-4-其他已知问题" class="headerlink" title="5.4 其他已知问题"></a>5.4 其他已知问题</h4><ul>
<li>Fling 状态传递偶有略微延迟（跟递归查找滑动子 View 有关，如果要优化可从外部传入状态，省去查找时间，为了保持灵活性暂未处理）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于设计一个复用性较强的控件，需要考虑的问题比较多，有些比较细节的问题处理得当的话对于交互体验会有舒适感上升的感觉，虽说这对用户体验是一个隐性的提升，但是就是众多细节的优化积累使得整体的用户体验得到大幅提示。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2020/07/02/trie_queue/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div class="copyright"><p>© 2015 - 2020 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>