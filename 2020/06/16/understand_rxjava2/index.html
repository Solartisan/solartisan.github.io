<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 两张图彻底理解 RxJava2 的核心原理 · Solartisan</title><meta name="description" content="两张图彻底理解 RxJava2 的核心原理 - solart"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">两张图彻底理解 RxJava2 的核心原理</h1><div class="post-info">Jun 16, 2020</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">solart</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p>文章似乎有些标题党的嫌疑，但是我相信根据我的理解画出两幅图可以让大家理解 RxJava2 的核心原理，稍后不要吝啬，请叫我灵魂画手😄！相信 <code>RxJava</code> 是大家业务中用到比较多的一个依赖库，RxJava 的强大之处在于它改变了程序员的编程习惯，相比较其他的开源项目，Rxjava 是最弯弯绕的一个。对于 RxJava 种类繁多的操作符，大多数同学都表示很是头疼，也有不少同学陷入了学习操作符不能停的怪圈。操作符要不要学，当然要，但是如果能理解 RxJava 的核心，操作符的使用就像是学会九阳神功的张无忌学招数，必定是手到擒来。所谓器欲尽其用，必先得其法。</p>
<h3 id="这篇文章我会讲些什么"><a href="#这篇文章我会讲些什么" class="headerlink" title="这篇文章我会讲些什么"></a>这篇文章我会讲些什么</h3><ul>
<li>RxJava2 基本的运行流程</li>
<li>RxJava2 线程切换的原理（涉及到为什么 subscribeOn() 只有第一次调用时有效）</li>
<li>为什么一订阅就回调了 onSubscribe</li>
<li>为什么 subscribeOn() 对上面的代码生效，observerOn() 对下面代码生效</li>
</ul>
<p>以下内容如果涉及到自己写的代码我会采用 Kotlin 进行示例展示，涉及到 RxJava2 会展示部分源码。</p>
<h2 id="1、简单的链式调用（无线程切换）"><a href="#1、简单的链式调用（无线程切换）" class="headerlink" title="1、简单的链式调用（无线程切换）"></a>1、简单的链式调用（无线程切换）</h2><a id="more"></a>
<p>先来看一段示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">object</span> : ObservableOnSubscribe<span class="type">&lt;String&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subscribe</span><span class="params">(emitter: <span class="typename">ObservableEmitter&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">                Log.d(<span class="string">"solart"</span>, <span class="string">"subscribe &gt; $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                emitter.onNext(<span class="string">"test"</span>)</span><br><span class="line">                emitter.onComplete()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).flatMap(<span class="keyword">object</span> : Function<span class="type">&lt;String, Observable&lt;String&gt;</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="typename">String</span>)</span>: Observable<span class="type">&lt;String&gt;</span> &#123;</span></span><br><span class="line">                <span class="keyword">return</span> Observable.just(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(<span class="keyword">object</span> : Function<span class="type">&lt;String, Int&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="typename">String</span>)</span>: Int &#123;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">object</span> : Observer<span class="type">&lt;Int&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="typename">Disposable</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onSubscribe &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(t: <span class="typename">Int</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onNext &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onComplete &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="typename">Throwable</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onError &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码中我们简单用了 <code>create</code>、<code>flatMap</code>、<code>map</code>等操作符，进行了流式的数据转换，最后我们通过 <code>subscribe</code> 订阅了数据流，其实通过查看源码我们不难发现， RxJava 本身是个逆向订阅的过程，话不多说先看图</p>
<p><img src="/images/rxjava2.png" alt="rxjava2"></p>
<p><a href="http://solart.cc/images/rxjava2.png" target="_blank">点击查看大图</a></p>
<h4 id="1-1-数据源的包裹"><a href="#1-1-数据源的包裹" class="headerlink" title="1.1 数据源的包裹"></a>1.1 数据源的包裹</h4><p>比照着这张图，我们来看一下，首先<code>蓝色虚线</code>部分是我们代码中实际调用的顺序，查看 <code>Observable.create</code> 我们不难发现，此处就是产生了一个 <code>ObservableCreate</code> 实例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">       ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">       <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如我们图中所示， <code>ObservableCreate</code> 内部包含一个类型为 <code>ObservableOnSubscribe&lt;T&gt;</code> 的 <code>source</code> 变量，根据我们代码中的调用，这个 <code>source</code> 就是我们 Kotlin 代码中的匿名对象 <code>object : ObservableOnSubscribe&lt;String&gt;</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们顺着代码的调用顺序，继续看一下 <code>flatMap</code> 的方法中又做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper,</span><br><span class="line">            <span class="keyword">boolean</span> delayErrors, <span class="keyword">int</span> maxConcurrency, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFlatMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper, delayErrors, maxConcurrency, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的产生了一个 <code>ObservableFlatMap</code> 实例，而其内部持有一个类型为 <code>ObservableSource&lt;T&gt;</code>的 <code>source</code> 变量，而该 source 则是上一步中的 <code>ObservableCreate</code> 实例，依次我们看 <code>map</code> 依然是类似的代码，这里不在赘述，所以到此我们得到了图中蓝色虚线部分的内容，这个过程可以看作是一个将数据源层层打包的过程。</p>
<h4 id="1-2-逆向订阅数据源"><a href="#1-2-逆向订阅数据源" class="headerlink" title="1.2 逆向订阅数据源"></a>1.2 逆向订阅数据源</h4><p>我们知道以上的代码调用并没有出发数据的流转，只有当我们调用 <code>subscribe</code> 时（图中上半部分红色实线部分）才真正触发了 RxJava 的数据流，我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">            ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重点！！！ 发生订阅的核心方法</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据我们上面的分析，执行 <code>subscribeActual</code> 的对象其实是 <code>ObservableMap</code> ，我们来看它的 <code>subscribeActual</code> 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此时产生了一个 <code>MapObserver</code> 对象，<code>MapObserver</code> 中通过 <code>actual</code> 持有了我们自己的匿名对象 <code>object : Observer&lt;Int&gt;</code> ，同样的，<code>ObservableMap</code> 执行 subscribeActual 又调用了上层的 <code>source.subscribe</code> ，依次逆向调用，就得到了我们图中上半部分的红线内容，这个过程我们可以称之为数据源的逆向订阅，这个过程同样也是一个层层打包的过程，只不过它打包的对象换成了观察者 Observer。</p>
<h4 id="1-3-触发数据源产生原始数据，数据流转"><a href="#1-3-触发数据源产生原始数据，数据流转" class="headerlink" title="1.3 触发数据源产生原始数据，数据流转"></a>1.3 触发数据源产生原始数据，数据流转</h4><p>当订阅发生在最顶层时，也就是 <code>ObservableCreate</code> 中的 <code>subscribeActual</code> ，此时触发了数据源的产生，通过 <code>emitter</code> 发射数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent); <span class="comment">//此时触发了 onSubscribe 回调，这里先提一下</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们代码中此时产生了真正的数据</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subscribe</span><span class="params">(emitter: <span class="typename">ObservableEmitter&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">                Log.d(<span class="string">"solart"</span>, <span class="string">"subscribe &gt; $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                emitter.onNext(<span class="string">"test"</span>)</span><br><span class="line">                emitter.onComplete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们再来看 <code>CreateEmitter</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                observer.onNext(t);  <span class="comment">//向下层分发数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>根据我们上面的分析 <code>CreateEmitter</code> 中持有的 <code>observer</code> 即是 <code>FlatMapObserver</code> 的实例，而 <code>FlatMapObserver</code> 调用 onNext 时，又会调用 <code>MapObserver</code> 的 onNext ，依次调用至我们自己实现的观察者的 onNext 处理数据，此时数据流转完毕。</p>
<p>观察我们这个图，你会发现，<code>操作符</code> 对应产生的被观察者和观察者命名规则很有规律，比如说被观察者的命名 <code>Observable + 操作符</code> ，例如 <code>ObservableMap</code> = Observable + map，观察者命名大多遵循 <code>操作符 + Observer</code> ，例如 <code>FlatMapObserver</code> = flatMap + Observer。除了命名规则外，我们观察整个流程，你也会发现有两个包裹封装的过程，一个是按照代码顺序的操作符产生了一个一层层的数据源包裹（蓝色虚线的流程部分），另外一个是在逆向订阅时，将观察者按照订阅顺序打包成一个一层层的观察者包裹（上部分的红色流程部分）。</p>
<h2 id="2、异步事件流编程（线程切换）"><a href="#2、异步事件流编程（线程切换）" class="headerlink" title="2、异步事件流编程（线程切换）"></a>2、异步事件流编程（线程切换）</h2><p>相信有了上面的分析，大家对 RxJava 的逆向订阅以及数据流转有了一定的认识，但是 RxJava 的强大之处在于它的异步事件流编程方式，随心所欲的切换工作线程，下面我们来分析它是如何做到的。</p>
<p>同样的我们还是先给出一个简单的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">object</span> : ObservableOnSubscribe<span class="type">&lt;String&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subscribe</span><span class="params">(emitter: <span class="typename">ObservableEmitter&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"subscribe &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                    emitter.onNext(<span class="string">"test"</span>)</span><br><span class="line">                    emitter.onComplete()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">                .map(<span class="keyword">object</span> : Function<span class="type">&lt;String, Int&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="typename">String</span>)</span>: Int &#123;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">object</span> : Observer<span class="type">&lt;Int&gt;</span> &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="typename">Disposable</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onSubscribe &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(t: <span class="typename">Int</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onNext &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onComplete &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="typename">Throwable</span>)</span> &#123;</span></span><br><span class="line">                    Log.d(<span class="string">"solart"</span>, <span class="string">"onError &gt;  $&#123;Thread.currentThread().name&#125;"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<p>这里简化了操作符的调用，以切换线程为示例，根据这段代码，我画出了这个过程的流程图（灵魂画手有没有？）如下：</p>
<p><img src="/images/rxjava2_with_scheduler.png" alt="rxjava2_with_scheduler"></p>
<p><a href="http://solart.cc/images/rxjava2_with_scheduler.png" target="_blank">点击查看大图</a></p>
<p>图中不同颜色（红、绿、紫）的实线表示流程所属不同线程，体现在不同线程中的过程，且标上了对应的序号，方便大家观看，这个图已经能够揭示 RxJava 运转的核心原理。</p>
<h4 id="2-1-逆向订阅时触发-subscribeOn-的线程切换"><a href="#2-1-逆向订阅时触发-subscribeOn-的线程切换" class="headerlink" title="2.1 逆向订阅时触发 subscribeOn 的线程切换"></a>2.1 逆向订阅时触发 subscribeOn 的线程切换</h4><p>根据我们第一部分的分析，我们知道 RxJava 有两个包裹封装的过程，一个是按照代码顺序的操作符产生了一个一层层的数据源包裹，另外一个是在逆向订阅时，将观察者按照订阅顺序打包成一个一层层的观察者包裹，虽然我们在代码调用过程中使用了线程切换（subscribeOn 和 observerOn）这两个特殊的操作符，在整个流程中依然遵循了这两个包裹封装的过程，只不过它的特殊之处在于处理时完成了流程上的线程切换。</p>
<p>我们来看订阅时（图中⑦⑧的流程）切换线程的 <code>ObservableSubscribeOn</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class="line"></span><br><span class="line">        s.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在逆向订阅的流程中，通过指定 <code>Scheduler</code> 将 <code>SubscribeTask</code> 任务交给线程池处理，我们先来看一下 <code>SubscribeTask</code> 的代码，就是执行了订阅：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            source.subscribe(parent); <span class="comment">// 仅仅订阅了一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看 <code>scheduler.scheduleDirect()</code> 中是如何做到线程切换的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Worker <span class="title">createWorker</span><span class="params">()</span></span>; <span class="comment">// 实现类中实现</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Worker w = createWorker(); <span class="comment">// 创建一个 worker</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">        w.schedule(task, delay, unit); <span class="comment">//执行任务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们示例中是切换到了 <code>io</code> 线程，所以我们对应的看一下 <code>IoScheduler</code> 的部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IoScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable tasks;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean once = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">        EventLoopWorker(CachedWorkerPool pool) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.tasks = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line">            <span class="keyword">this</span>.threadWorker = pool.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@NonNull</span></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (tasks.isDisposed()) &#123;</span><br><span class="line">                <span class="comment">// don't schedule, we are unsubscribed</span></span><br><span class="line">                <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> <span class="keyword">extends</span> <span class="title">NewThreadWorker</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 此处粘贴了了父类中的实现</span></span><br><span class="line">        <span class="annotation">@NonNull</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class="line">            Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">            ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Future&lt;?&gt; f;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程池执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                     f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">                &#125;</span><br><span class="line">                sr.setFuture(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> sr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综合上面的代码，我们来总结一下，其实  <code>ObservableSubscribeOn</code> 本身就是在 <code>subscribeActual</code> 中将上层数据源在异步线程中执行订阅，这样就完成了线程的切换，后续的流程都会在这个切换后的线程中执行，直到再次切换线程。因为 RxJava 本身是逆向订阅的流程，所以这里就解释了两个问题：1、为什么 subscribeOn() 对上面的代码生效？2、为什么 subscribeOn() 只有第一次调用时有效？归根结底都是因为逆向订阅的流程决定了 subscribeOn 是在订阅流程中起作用，此时数据还未产生，而在代码上第一个 subscribeOn 其实是逆向订阅流程的最后一个线程切换的地方 。这里还有一点要提一下，<code>ObservableSubscribeOn</code> 在执行 <code>subscribeActual</code> 时，回调了下层产生的 <code>Observer</code> 的 <code>onSubscribe</code>，如图中的④⑤⑥流程，所以这也是为什么，在观察者一订阅后就会在当前订阅的线程收到 <code>onSubscribe</code> 的回调的原因。</p>
<h4 id="2-2-正向数据流触发-observerOn-的线程切换"><a href="#2-2-正向数据流触发-observerOn-的线程切换" class="headerlink" title="2.2 正向数据流触发 observerOn 的线程切换"></a>2.2 正向数据流触发 observerOn 的线程切换</h4><p>同第一部分一样的，订阅到最上层时，触发数据源产生原始数据，从而又正向的流转数据，此过程我们不在详细分析，参照1.3，我们着重看一下 <code>ObserveOnObserver</code> 的 onNext 处理的逻辑，也就是图中步骤⑮⑯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; actual;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.Worker worker;</span><br><span class="line">        ...</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">                queue.offer(t);</span><br><span class="line">            &#125;</span><br><span class="line">            schedule(); <span class="comment">//类似 ObservableSubscribeOn.subscribeActual() 异步线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">                worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">                drainFused();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                drainNormal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中我们此时切换到了 <code>Main</code> 线程中执行，我们来看对应的 <code>HandlerScheduler</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> async;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (run == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"run == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit == null"</span>);</span><br><span class="line"></span><br><span class="line">        run = RxJavaPlugins.onSchedule(run);</span><br><span class="line">        ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</span><br><span class="line">        handler.postDelayed(scheduled, unit.toMillis(delay));</span><br><span class="line">        <span class="keyword">return</span> scheduled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HandlerWorker(handler, async);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="annotation">@SuppressLint</span>(<span class="string">"NewApi"</span>) <span class="comment">// Async will only be true when the API is available to call.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            run = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">            ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</span><br><span class="line"></span><br><span class="line">            Message message = Message.obtain(handler, scheduled);</span><br><span class="line">            message.obj = <span class="keyword">this</span>; <span class="comment">// Used as token for batch disposal of this worker's runnables.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                message.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handler.sendMessageDelayed(message, unit.toMillis(delay));</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> scheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看到，此时将 <code>Runnable</code> 通过 Handler 发到了住线程去执行，所以经过此步骤后，后续的 onNext 的处理已经切换为主线程。同样的，这里也解释了一开始我们提到的另一个问题：为什么 observerOn() 对下面代码生效？正是因为，数据的流向决定了 observerOn() 对后续的 onNext 产生影响。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此 RxJava 运转机制我们已经分析完毕，大家可以比照图中流程，跟踪代码调用关系，相信会有很大收获。 RxJava 本身是一个变种的观察者模式，正是因为框架本身要实现<code>异步事件流编程</code>，所以产生了逆向订阅的过程，同时数据又是正向流转的，这个过程中大家还需要理解两个包裹封装（被观察者、观察者）的过程，不管操作符怎么变换，都不会脱离这样的运作核心。</p>
<p>另外根据不同的操作符的实现，我们依照同样的模式，可实现自己的自定义操作符，只要能在订阅时和数据回流时做好上下层的衔接就好，这个大家可以自己实践。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/07/07/gradle-migrate-3.0.0+/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div class="copyright"><p>© 2015 - 2020 <a href="http://solart.cc">solart</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>