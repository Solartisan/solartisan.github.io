<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Compose 渲染过程分析 · Solartisan</title><meta name="description" content="Compose 渲染过程分析 - Oz"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://solart.cc/atom.xml" title="Solartisan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/solartisan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Compose 渲染过程分析</h1><div class="post-info">Jan 23, 2023</div><div class="post-content"><p>作者：<a href="mailto://imilko7@gmail.com" target="_blank" rel="external">Oz</a></p>
<blockquote>
<p>版权声明：本文图文为博主原创，转载请注明出处。</p>
</blockquote>
<p><code>Compose</code> 作为一个新兴高效的 UI 框架，它使用声明式的语言来构建 UI，同时，它还使用惰性计算来优化 UI 的性能。目前在线上的业务中已经有了落地实践，例如实感骑容器、KS 等项目。正所谓知其然也要知其所以然，为了探究 <code>Compose</code> 的实现原理，对部分源码进行了阅读整理，这里尝试回答以下几个问题：</p>
<ul>
<li><p>作为一种新的 UI 框架它是如何将 <code>Compose UI</code> 渲染到屏幕上的？★★★★★</p>
</li>
<li><p>平常在写代码时，经常用到 <code>LaunchedEffect</code>、<code>SideEffect</code> 是怎么样生效的？ ★</p>
</li>
<li><p><code>CompositionLocal</code> 通过 <code>@Composable</code> 函数隐式向下传递数据，它又是怎么样发挥作用的？★</p>
</li>
<li><p><code>@Composable</code> <code>AndroidView</code> 是怎么和 <code>Compose</code> 进行组合渲染的？★★</p>
</li>
</ul>
<h1 id="Pre-Start"><a href="#Pre-Start" class="headerlink" title="Pre-Start"></a>Pre-Start</h1><p>进入正题前，我们先看看官方的介绍：</p>
<blockquote>
<p><a href="https://developer.android.com/jetpack/compose/phases?hl=zh-cn" target="_blank" rel="external">https://developer.android.com/jetpack/compose/phases?hl=zh-cn</a></p>
<p>与大多数其他界面工具包一样，Compose 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 Android View 系统，就会发现它有 3 个主要阶段：<strong>测量、布局和绘制</strong>。Compose 和它非常相似，但开头多了一个叫做“组合”的重要阶段。</p>
<p><strong>帧的 3 个阶段</strong></p>
<p>Compose 有 3 个主要阶段：</p>
<ol>
<li><p><strong>组合</strong>：要显示什么样的界面。Compose 运行可组合函数并创建界面说明。</p>
</li>
<li><p><strong>布局</strong>：要放置界面的位置。该阶段包含两个步骤：测量和放置。对于布局树中的每个节点，布局元素都会根据 2D 坐标来测量并放置自己及其所有子元素。</p>
</li>
<li><p><strong>绘制</strong>：渲染的方式。界面元素会绘制到画布（通常是设备屏幕）中。</p>
</li>
</ol>
<p><img src="/images/compose-phases.png" alt="Compose Phases"></p>
</blockquote>
<p>以上，官方基本将渲染的关键流程讲出来了，但是还比较抽象。为了了解得更具体深入一些，我们有必要钻研一下 Compose 的源码。我们先来看一个实际使用的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComposeActivity</span>: <span class="typename">ComponentActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            Text(text = <span class="string">"Hello World!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实际画的内容是什么并不重要，重要的是我们从 <code>setContent</code> 这个入口追踪一下流程中发生了什么。</p>
<h1 id="1-1-Compose-环境初始化"><a href="#1-1-Compose-环境初始化" class="headerlink" title="1.1 Compose 环境初始化"></a>1.1 Compose 环境初始化</h1><p>首先，为了更快的让大家了解 <code>setContent</code> 这个过程发生了什么，我们可以先看整理好的流程图：</p>
<p><img src="/images/compose-create-composition.png" alt="compose-create-composition.png"></p>
<p>下面我们来通过代码流程，看下这里面都做了哪些事。</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">setContent</span><span class="params">(</span><br><span class="line">    parent: <span class="typename">CompositionContext?</span> = null,</span><br><span class="line">    content: <span class="typename">@Composable (</span>)</span> -&gt; Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> existingComposeView</span> = window.decorView</span><br><span class="line">        .findViewById<span class="type">&lt;ViewGroup&gt;</span>(android.R.id.content)</span><br><span class="line">        .getChildAt(<span class="number">0</span>) <span class="keyword">as</span>? ComposeView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingComposeView != <span class="literal">null</span>) with(existingComposeView) &#123;</span><br><span class="line">        setParentCompositionContext(parent)</span><br><span class="line">        setContent(content)</span><br><span class="line">    &#125; <span class="keyword">else</span> ComposeView(this).apply &#123;</span><br><span class="line">        <span class="comment">// Set content and parent **before** setContentView</span></span><br><span class="line">        <span class="comment">// to have ComposeView create the composition on attach</span></span><br><span class="line">        setParentCompositionContext(parent)</span><br><span class="line">        setContent(content)</span><br><span class="line">        <span class="comment">// Set the view tree owners before setting the content view so that the inflation process</span></span><br><span class="line">        <span class="comment">// and attach listeners will see them already present</span></span><br><span class="line">        setOwners()</span><br><span class="line">        setContentView(this, DefaultActivityContentLayoutParams)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setContent</code> 作为 <code>ComponentActivity</code> 的一个扩展函数，内部其实就是在构建一个 <code>ComposeView</code> 然后将 composeView 通过 <code>setContentView</code> 函数设置在 <code>android.R.id.content</code> 这个 Framelayout 上。</p>
<p>其实这里面有两处比较关键，一个是 <code>setParentCompositionContext</code>，另一个就是将 Composable 函数再次通过 <code>ComposeView.setContent</code> 函数传递了进去。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">AbstractComposeView</span> @<span class="title">JvmOverloads</span> <span class="title">constructor</span></span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setParentCompositionContext</span><span class="params">(parent: <span class="typename">CompositionContext?</span>)</span> &#123;</span></span><br><span class="line">        parentContext = parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setParentCompositionContext</code> 函数其实非常简单，只是将 parent 参数进行了一次赋值，那这个 <code>CompositionContext</code> 是什么呢，我们先放一下，回头再看。继续往下看，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposeView</span> @<span class="title">JvmOverloads</span> <span class="title">constructor</span></span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">) : AbstractComposeView(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> content</span> = mutableStateOf<span class="type">&lt;(@Composable () -&gt;</span> <span class="typename">Unit</span>)?&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Composable</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">Content</span><span class="params">()</span> &#123;</span></span><br><span class="line">        content.value?.invoke()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setContent</span><span class="params">(content: <span class="typename">@Composable (</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        shouldCreateCompositionOnAttachedToWindow = <span class="literal">true</span></span><br><span class="line">        this.content.value = content</span><br><span class="line">        <span class="keyword">if</span> (isAttachedToWindow) &#123;</span><br><span class="line">            createComposition()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也不复杂，将 Composable 函数进行了赋值，在 <code>Content()</code> 函数被使用的时候进行 invoke 调用。不过在此处就开始逐步发现关键点了，这里进行 <code>createComposition()</code> 调用，这与官方提到的 <code>组合</code> 有点关联上了，我们继续往下看。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">AbstractComposeView</span> @<span class="title">JvmOverloads</span> <span class="title">constructor</span></span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createComposition</span><span class="params">()</span> &#123;</span></span><br><span class="line">        check(parentContext != <span class="literal">null</span> || isAttachedToWindow) &#123;</span><br><span class="line">            <span class="string">"createComposition requires either a parent reference or the View to be attached"</span> +</span><br><span class="line">                <span class="string">"to a window. Attach the View or call setParentCompositionReference."</span></span><br><span class="line">        &#125;</span><br><span class="line">        ensureCompositionCreated()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 确定当前 View 组合的父级的正确 CompositionContext。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resolveParentCompositionContext</span><span class="params">()</span> = parentContext</span></span><br><span class="line">        ?: findViewTreeCompositionContext()?.cacheIfAlive()</span><br><span class="line">        ?: cachedViewTreeCompositionContext?.<span class="keyword">get</span>()?.takeIf &#123; it.isAlive &#125;</span><br><span class="line">        ?: windowRecomposer.cacheIfAlive()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ensureCompositionCreated</span><span class="params">()</span> &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (composition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                creatingComposition = <span class="literal">true</span></span><br><span class="line">                composition = setContent(resolveParentCompositionContext()) &#123;</span><br><span class="line">                    Content()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                creatingComposition = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处又出现了两个关键函数，一个是 <code>resolveParentCompositionContext</code> 此函数的调用链很长，但其实只做了一件事，就是确保 <code>CompositionContext</code> 能够被确定，如果是第一次，则 parentContext 一定是 Recomposer；另一个就是再次出现一个 <code>setContent</code> 函数，函数的入惨是 <code>CompositionContext</code> 与 <code>Composable 函数</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将 Composable 组合到 AndroidComposeView 中</span><br><span class="line"> * 通过提供的 parent CompositionContext，新的 Composable 函数可以在逻辑上“链接”到现有的 Composition。</span><br><span class="line"> */</span></span><br><span class="line">internal <span class="function"><span class="keyword">fun</span> AbstractComposeView.<span class="title">setContent</span><span class="params">(</span><br><span class="line">    parent: <span class="typename">CompositionContext,</span><br><span class="line">    content: @Composable (</span>)</span> -&gt; Unit</span></span><br><span class="line">): Composition &#123;</span><br><span class="line">    GlobalSnapshotManager.ensureStarted()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> composeView</span> =</span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            getChildAt(<span class="number">0</span>) <span class="keyword">as</span>? AndroidComposeView</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllViews(); <span class="literal">null</span></span><br><span class="line">        &#125; ?: AndroidComposeView(context, parent.effectCoroutineContext).also &#123;</span><br><span class="line">            addView(it.view, DefaultLayoutParams)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> doSetContent(composeView, parent, content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetContent</span><span class="params">(</span><br><span class="line">    owner: <span class="typename">AndroidComposeView,</span><br><span class="line">    parent: CompositionContext,</span><br><span class="line">    content: @Composable (</span>)</span> -&gt; Unit</span></span><br><span class="line">): Composition &#123;</span><br><span class="line">    <span class="keyword">if</span> (inspectionWanted(owner)) &#123;</span><br><span class="line">        owner.setTag(</span><br><span class="line">            R.id.inspection_slot_table_set,</span><br><span class="line">            Collections.newSetFromMap(WeakHashMap<span class="type">&lt;CompositionData, Boolean&gt;</span>())</span><br><span class="line">        )</span><br><span class="line">        enableDebugInspectorInfo()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 UiApplier，从而构建 Composition，以便后续构建 Compose UI</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> original</span> = Composition(UiApplier(owner.root), parent)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> wrapped</span> = owner.view.getTag(R.id.wrapped_composition_tag)</span><br><span class="line">        <span class="keyword">as</span>? WrappedComposition</span><br><span class="line">        ?: WrappedComposition(owner, original).also &#123;</span><br><span class="line">            owner.view.setTag(R.id.wrapped_composition_tag, it)</span><br><span class="line">        &#125;</span><br><span class="line">    wrapped.setContent(content)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>AbstractComposeView.setContent</code> 扩展函数中出现了比较密集的信息。首先就是启动了全局的快照管理（至于快照是做什么的，我们此处不展开），其次就是创建一个 <code>AndroidComposeView</code> 并且将此 View 添加到 <code>ComposeView</code> 中。</p>
<p>继续往下看，在 <code>doSetContent</code> 函数中构建了 <code>UiApplier</code> 和 <code>Composition</code>，根据参数，其实可以看到 <code>AndroidComposeView</code> 中有持有一个 <code>root LayoutNode</code>，此时我们基本上就可以合理推测 <code>AndroidComposeView</code> 就是最终负责 Compose UI 渲染的 View。而 <code>UiApplier</code> 则负责申请在合成期间发出的基于树的操作。<code>Composition</code> 则是管理 Composable 组合的过程，查看 Composition 的源码可以发现其中 <code>CompositionImpl</code> 持有 <code>SlotTable</code> 和 <code>ComposerImpl</code> 这个则是 Composition 的关键，具体的我们等后面再分析。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedComposition</span></span>(</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> owner</span>: AndroidComposeView,</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> original</span>: Composition</span><br><span class="line">) : Composition, LifecycleEventObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> disposed</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> addedToLifecycle</span>: Lifecycle? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> lastContent</span>: @Composable () -&gt; <span class="typename">Unit</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContent</span><span class="params">(content: <span class="typename">@Composable (</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        owner.setOnViewTreeOwnersAvailable &#123;</span><br><span class="line">            <span class="keyword">if</span> (!disposed) &#123;</span><br><span class="line">                <span class="variable"><span class="keyword">val</span> lifecycle</span> = it.lifecycleOwner.lifecycle</span><br><span class="line">                lastContent = content</span><br><span class="line">                <span class="keyword">if</span> (addedToLifecycle == <span class="literal">null</span>) &#123;</span><br><span class="line">                    addedToLifecycle = lifecycle</span><br><span class="line">                    lifecycle.addObserver(this)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lifecycle.currentState.isAtLeast(Lifecycle.State.CREATED)) &#123;</span><br><span class="line">                    original.setContent &#123;</span><br><span class="line"></span><br><span class="line">                        @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">                        <span class="variable"><span class="keyword">val</span> inspectionTable</span> =</span><br><span class="line">                            owner.getTag(R.id.inspection_slot_table_set) <span class="keyword">as</span>?</span><br><span class="line">                                MutableSet<span class="type">&lt;CompositionData&gt;</span></span><br><span class="line">                                ?: (owner.parent <span class="keyword">as</span>? View)?.getTag(R.id.inspection_slot_table_set)</span><br><span class="line">                                    <span class="keyword">as</span>? MutableSet<span class="type">&lt;CompositionData&gt;</span></span><br><span class="line">                        <span class="keyword">if</span> (inspectionTable != <span class="literal">null</span>) &#123;</span><br><span class="line">                            inspectionTable.add(currentComposer.compositionData)</span><br><span class="line">                            currentComposer.collectParameterInformation()</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        LaunchedEffect(owner) &#123; owner.keyboardVisibilityEventLoop() &#125;</span><br><span class="line">                        LaunchedEffect(owner) &#123; owner.boundsUpdatesEventLoop() &#125;</span><br><span class="line"></span><br><span class="line">                        CompositionLocalProvider(LocalInspectionTables provides inspectionTable) &#123;</span><br><span class="line">                            ProvideAndroidCompositionLocals(owner, content)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看， <code>doSetContent</code> 函数将 Composition 和 AndroidComposeView 又传递进 <code>WrappedComposition</code> 包装类中，并在 setContent 函数中设置 <code>owner.setOnViewTreeOwnersAvailable</code> 的回调函数，此回调函数触发的时机是 <code>AndroidComposeView</code> 生命周期在 <code>onAttachedToWindow</code> 后。并在 Lifecycle 生命周期处于 <em>CREATED 后，此时，**<code>original.setContent</code></em> 将前面流程中设置在 ComposeView 中的 Composable 函数 Content() 包裹在 CompositionLocalProvider 中，CompositionLocalProvider 则提供了LocalConfiguration、LocalContext 等等隐性数据。</p>
<p>至此，Compose 的初始化流程已经结束，我们总结一下，整个流程出现了 <code>ComposeView</code> 和 <code>AndroidComposeView</code> 两个 ViewGroup，<code>ComposeView</code> 负责对 Android 平台的适配并构建 Composition 相关环境， <code>AndroidComposeView</code> 负责连接 LayoutNode 视图系统与 View 视图系统。这其中最重要的就是创建了 <code>CompositionImpl</code> 且将 <code>AndroidComposeView</code> 和 <code>CompositionImpl</code> 通过包装类 <code>WrappedComposition</code> 进行关联，从而完成了 Composition 的环境的构建，为后续流程做好了准备工作。</p>
<h1 id="1-2-Compostion-解析-Composable-（Composition-流程）"><a href="#1-2-Compostion-解析-Composable-（Composition-流程）" class="headerlink" title="1.2 Compostion 解析 @Composable （Composition 流程）"></a>1.2 Compostion 解析 @Composable （Composition 流程）</h1><p>上面的部分提到了在 Activity <code>onCreate</code> 的生命周期中通过 <code>setContent</code> 函数为整个 Compose 创建好了环境，那接下来我们就看看后续事怎么将 <code>@Composable</code> 函数进行 UI 解析的吧。类比，原生 View 的 xml 布局的视图体系，其实我们也可以大致猜测会通过某些方式将 <code>@Composable</code> 函数解析成视图树，那究竟是怎样做的，我们不妨来研究一下。</p>
<p>首先，还是先看整理的流程图：</p>
<p><img src="/images/compose-composition.png" alt="compose-composition.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">AndroidComposeView</span></span>(context: Context) :</span><br><span class="line">    ViewGroup(context), Owner, ViewRootForTest, PositionCalculator, DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnViewTreeOwnersAvailable</span><span class="params">(callback: <span class="typename">(ViewTreeOwners</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> viewTreeOwners</span> = viewTreeOwners</span><br><span class="line">        <span class="keyword">if</span> (viewTreeOwners != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback(viewTreeOwners)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isAttachedToWindow) &#123;</span><br><span class="line">            onViewTreeOwnersAvailable = callback</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> &#123;</span></span><br><span class="line">        super.onAttachedToWindow()</span><br><span class="line">        invalidateLayoutNodeMeasurement(root)</span><br><span class="line">        invalidateLayers(root)</span><br><span class="line">        snapshotObserver.startObserving()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (resetViewTreeOwner) &#123;</span><br><span class="line">            this.viewTreeOwners = viewTreeOwners</span><br><span class="line">            onViewTreeOwnersAvailable?.invoke(viewTreeOwners)</span><br><span class="line">            onViewTreeOwnersAvailable = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到 <code>WrappedComposition</code> 在 setContent 函数中设置 <code>owner.setOnViewTreeOwnersAvailable</code> 的回调函数，那我们来看下回调执行的时机，其实不难发现正常的回调实际就是在 AndroidComposeView 的生命周期的 <code>onAttachedToWindow</code> 时，所以我们顺着这个路径继续往下看。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedComposition</span></span>(</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> owner</span>: AndroidComposeView,</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> original</span>: Composition</span><br><span class="line">) : Composition, LifecycleEventObserver &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> lastContent</span>: @Composable () -&gt; <span class="typename">Unit</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContent</span><span class="params">(content: <span class="typename">@Composable (</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        owner.setOnViewTreeOwnersAvailable &#123;</span><br><span class="line">            <span class="keyword">if</span> (!disposed) &#123;</span><br><span class="line">                <span class="variable"><span class="keyword">val</span> lifecycle</span> = it.lifecycleOwner.lifecycle</span><br><span class="line">                lastContent = content</span><br><span class="line">                <span class="keyword">if</span> (addedToLifecycle == <span class="literal">null</span>) &#123;</span><br><span class="line">                    addedToLifecycle = lifecycle</span><br><span class="line">                    lifecycle.addObserver(this)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lifecycle.currentState.isAtLeast(Lifecycle.State.CREATED)) &#123;</span><br><span class="line">                    original.setContent &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="typename">LifecycleOwner, event: Lifecycle.Event</span>)</span> &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">            dispose()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!disposed) &#123;</span><br><span class="line">                setContent(lastContent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以看出来 <code>setOnViewTreeOwnersAvailable</code> 回调函数被执行时，会通过 <code>original.setContent</code> 完成对 @Composable 的组合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">CompositionImpl</span></span>(</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 父 composition 的 [rememberCompositionContext] 用于 sub-compositions，</span><br><span class="line">     * 或是 root compositions 的一个 [Recomposer] 实例。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> parent</span>: CompositionContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Applier，用来更新 composition 管理的树结构</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> applier</span>: Applier<span class="type">&lt;*&gt;</span>,</span><br><span class="line"></span><br><span class="line">    recomposeContext: CoroutineContext? = <span class="literal">null</span></span><br><span class="line">) : ControlledComposition, RecomposeScopeOwner &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * [SlotTable] 用于存储重组所需的 composition 信息。</span><br><span class="line">     */</span></span><br><span class="line">    internal <span class="variable"><span class="keyword">val</span> slotTable</span> = SlotTable()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 用于创建和更新此组合管理的树的 [Composer]。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> composer</span>: ComposerImpl =</span><br><span class="line">        ComposerImpl(</span><br><span class="line">            applier = applier,</span><br><span class="line">            parentContext = parent,</span><br><span class="line">            slotTable = slotTable,</span><br><span class="line">            abandonSet = abandonSet,</span><br><span class="line">            changes = changes,</span><br><span class="line">            lateChanges = lateChanges,</span><br><span class="line">            composition = this</span><br><span class="line">        ).also &#123;</span><br><span class="line">            parent.registerComposer(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContent</span><span class="params">(content: <span class="typename">@Composable (</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        check(!disposed) &#123; <span class="string">"The composition is disposed"</span> &#125;</span><br><span class="line">        this.composable = content</span><br><span class="line">        parent.composeInitial(this, composable)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 <code>setContent</code> 中用到 <code>parent</code> 是什么呢，如果大家还有印象的话在 Composition 初始化的过程中有个 <code>ComposeView.resolveParentCompositionContext</code> 的过程，在这个过程中确认初始化的是 <code>windowRecomposer</code> 这个对象对应就是 <code>Recomposer</code>。那对应的就是 <code>Recomposer</code> 的 <code>composeInitial</code> 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@OptIn(InternalComposeApi::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">CompositionContext</span> <span class="title">internal</span> <span class="title">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    internal abstract <span class="variable"><span class="keyword">val</span> compoundHashKey</span>: <span class="typename">Int</span></span><br><span class="line">    internal abstract <span class="variable"><span class="keyword">val</span> collectingParameterInformation</span>: <span class="typename">Boolean</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  The [CoroutineContext] with which effects for the composition will be executed in.</span><br><span class="line">     **/</span></span><br><span class="line">    abstract <span class="variable"><span class="keyword">val</span> effectCoroutineContext</span>: CoroutineContext</span><br><span class="line">    internal abstract <span class="variable"><span class="keyword">val</span> recomposeCoroutineContext</span>: CoroutineContext</span><br><span class="line">    internal abstract <span class="function"><span class="keyword">fun</span> <span class="title">composeInitial</span><span class="params">(</span><br><span class="line">        composition: <span class="typename">ControlledComposition,</span><br><span class="line">        content: @Composable (</span>)</span> -&gt; Unit</span></span><br><span class="line">    )</span><br><span class="line">    internal abstract <span class="function"><span class="keyword">fun</span> <span class="title">invalidate</span><span class="params">(composition: <span class="typename">ControlledComposition</span>)</span></span></span><br><span class="line">    internal abstract <span class="function"><span class="keyword">fun</span> <span class="title">invalidateScope</span><span class="params">(scope: <span class="typename">RecomposeScopeImpl</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recomposer</span></span>(</span><br><span class="line">    effectCoroutineContext: CoroutineContext</span><br><span class="line">) : CompositionContext() &#123;</span><br><span class="line"></span><br><span class="line">    internal <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">composeInitial</span><span class="params">(</span><br><span class="line">        composition: <span class="typename">ControlledComposition,</span><br><span class="line">        content: @Composable (</span>)</span> -&gt; Unit</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> composerWasComposing</span> = composition.isComposing</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 解析 Composable 函数 -&gt; slotTable</span></span><br><span class="line">            composing(composition, <span class="literal">null</span>) &#123;</span><br><span class="line">                composition.composeContent(content)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            processCompositionError(e, composition, recoverable = <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 记录变更操作  nodes = change(applier, slotsWriter, rememberManager)</span></span><br><span class="line">            performInitialMovableContentInserts(composition)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            processCompositionError(e, composition, recoverable = <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 应用变更，实际转化为 LayoutNode 渲染树，invokeChanges()</span></span><br><span class="line">            composition.applyChanges()</span><br><span class="line">            composition.applyLateChanges()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            processCompositionError(e)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Recomposer.composeInitial</code> 函数中执行了 <code>composition.composeContent</code> 这个函数就是在对 <code>@Composable</code> 函数做解析，将 <code>@Composable</code> 解析成 <code>Slot Table</code> 的数据结构。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">ComposerImpl</span></span>(</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * An adapter that applies changes to the tree using the Applier abstraction.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="variable"><span class="keyword">val</span> applier</span>: Applier<span class="type">&lt;*&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Parent of this composition; a [Recomposer] for root-level compositions.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> parentContext</span>: CompositionContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The slot table to use to store composition data</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> slotTable</span>: SlotTable,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> abandonSet</span>: MutableSet<span class="type">&lt;RememberObserver&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> changes</span>: MutableList<span class="type">&lt;Change&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> lateChanges</span>: MutableList<span class="type">&lt;Change&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The composition that owns this composer</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="variable"><span class="keyword">val</span> composition</span>: ControlledComposition</span><br><span class="line">) : Composer &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    internal <span class="function"><span class="keyword">fun</span> <span class="title">composeContent</span><span class="params">(</span><br><span class="line">        invalidationsRequested: <span class="typename">IdentityArrayMap&lt;RecomposeScopeImpl, IdentityArraySet&lt;Any&gt;?&gt;,</span><br><span class="line">        content: @Composable (</span>)</span> -&gt; Unit</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        runtimeCheck(changes.isEmpty()) &#123; <span class="string">"Expected applyChanges() to have been called"</span> &#125;</span><br><span class="line">        doCompose(invalidationsRequested, content)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doCompose</span><span class="params">(</span><br><span class="line">        invalidationsRequested: <span class="typename">IdentityArrayMap&lt;RecomposeScopeImpl, IdentityArraySet&lt;Any&gt;?&gt;,</span><br><span class="line">        content: (@Composable (</span>)</span> -&gt; Unit)?</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        runtimeCheck(!isComposing) &#123; <span class="string">"Reentrant composition is not supported"</span> &#125;</span><br><span class="line">        trace(<span class="string">"Compose:recompose"</span>) &#123;</span><br><span class="line">            snapshot = currentSnapshot()</span><br><span class="line">            compositionToken = snapshot.id</span><br><span class="line">            providerUpdates.clear()</span><br><span class="line">            invalidationsRequested.forEach &#123; scope, <span class="keyword">set</span> -&gt;</span><br><span class="line">                <span class="variable"><span class="keyword">val</span> location</span> = scope.anchor?.location ?: <span class="keyword">return</span></span><br><span class="line">                invalidations.add(Invalidation(scope, location, <span class="keyword">set</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            invalidations.sortBy &#123; it.location &#125;</span><br><span class="line">            nodeIndex = <span class="number">0</span></span><br><span class="line">            <span class="variable"><span class="keyword">var</span> complete</span> = <span class="literal">false</span></span><br><span class="line">            isComposing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startRoot()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// vv Experimental for forced</span></span><br><span class="line">                @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">                <span class="variable"><span class="keyword">val</span> savedContent</span> = nextSlot()</span><br><span class="line">                <span class="keyword">if</span> (savedContent !== content &amp;&amp; content != <span class="literal">null</span>) &#123;</span><br><span class="line">                    updateValue(content <span class="keyword">as</span> Any?)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ^^ Experimental for forced</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ignore reads of derivedStateOf recalculations</span></span><br><span class="line">                observeDerivedStateRecalculations(</span><br><span class="line">                    start = &#123;</span><br><span class="line">                        childrenComposing++</span><br><span class="line">                    &#125;,</span><br><span class="line">                    done = &#123;</span><br><span class="line">                        childrenComposing--</span><br><span class="line">                    &#125;,</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (content != <span class="literal">null</span>) &#123;</span><br><span class="line">                        startGroup(invocationKey, invocation)</span><br><span class="line">                        invokeComposable(this, content)</span><br><span class="line">                        endGroup()</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">                        forciblyRecompose &amp;&amp;</span><br><span class="line">                        savedContent != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        savedContent != Composer.Empty</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        startGroup(invocationKey, invocation)</span><br><span class="line">                        @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">                        invokeComposable(this, savedContent <span class="keyword">as</span> @Composable () -&gt; <span class="typename">Unit</span>)</span><br><span class="line">                        endGroup()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        skipCurrentGroup()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                endRoot()</span><br><span class="line">                complete = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                isComposing = <span class="literal">false</span></span><br><span class="line">                invalidations.clear()</span><br><span class="line">                <span class="keyword">if</span> (!complete) abortRoot()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Comopsable</code> 首次执行时，产生的 Group 以及所有的状态会以此填充到 <code>Slot Table</code> 中，填充时会附带一个编译时给予代码位置生成的不重复的 key，所以 <code>Slot Table</code> 中的记录也被称作基于代码位置的存储（Positional Memoization）。<code>Slot Table</code> 中的状态不能直接用来渲染，UI 的渲染依赖 Composition 中的另一棵树 - LayoutNode Tree。</p>
<blockquote>
<p>Slot Table 又是一块非常复杂的内容，知识储备有限，此处不展开。</p>
<p>Slot Table 通过 Applier 转换成渲染树：</p>
<p><img src="/images/compose-applier.png" alt="compose-applier.png"></p>
</blockquote>
<p>在将 @Composable 解析成 Slot Table 的过程中，其实我们注意到有 <code>invokeComposable()</code> 的调用，这里就是在执行我们业务中写的 UI 逻辑代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">internal actual <span class="function"><span class="keyword">fun</span> <span class="title">invokeComposable</span><span class="params">(composer: <span class="typename">Composer, composable: @Composable (</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">    @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> realFn</span> = composable <span class="keyword">as</span> Function2<span class="type">&lt;Composer, Int, Unit&gt;</span></span><br><span class="line">    realFn(composer, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里额外提一下 <code>Function2&lt;Composer, Int, Unit&gt;</code> 这个函数在代码中并无实际定义，原因是 Compose Plugin 中对 @Composable 函数进行了修改，在编译过程中注入了 <code>$composer: Composer, $changed: Int</code> 参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cs.android.com</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerParamTransformer</span></span>(</span><br><span class="line">    context: IrPluginContext,</span><br><span class="line">    symbolRemapper: DeepCopySymbolRemapper,</span><br><span class="line">    stabilityInferencer: StabilityInferencer,</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> decoysEnabled</span>: <span class="typename">Boolean</span>,</span><br><span class="line">    metrics: ModuleMetrics,</span><br><span class="line">) :</span><br><span class="line">    AbstractComposeLowering(context, symbolRemapper, metrics, stabilityInferencer),</span><br><span class="line">    ModuleLoweringPass &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> IrSimpleFunction.<span class="title">copyWithComposerParam</span><span class="params">()</span>: IrSimpleFunction &#123;</span></span><br><span class="line">        assert(explicitParameters.lastOrNull()?.name != KtxNameConventions.COMPOSER_PARAMETER) &#123;</span><br><span class="line">            <span class="string">"Attempted to add composer param to $this, but it has already been added."</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy().also &#123; fn -&gt;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> oldFn</span> = this</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> it's important to add these here before we recurse into the body in</span></span><br><span class="line">            <span class="comment">// order to avoid an infinite loop on circular/recursive calls</span></span><br><span class="line">            transformedFunctionSet.add(fn)</span><br><span class="line">            transformedFunctions[oldFn] = fn</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The overridden symbols might also be composable functions, so we want to make sure</span></span><br><span class="line">            <span class="comment">// and transform them as well</span></span><br><span class="line">            fn.overriddenSymbols = overriddenSymbols.map &#123;</span><br><span class="line">                it.owner.withComposerParamIfNeeded().symbol</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if we are transforming a composable property, the jvm signature of the</span></span><br><span class="line">            <span class="comment">// corresponding getters and setters have a composer parameter. Since Kotlin uses the</span></span><br><span class="line">            <span class="comment">// lack of a parameter to determine if it is a getter, this breaks inlining for</span></span><br><span class="line">            <span class="comment">// composable property getters since it ends up looking for the wrong jvmSignature.</span></span><br><span class="line">            <span class="comment">// In this case, we manually add the appropriate "@JvmName" annotation so that the</span></span><br><span class="line">            <span class="comment">// inliner doesn't get confused.</span></span><br><span class="line">            fn.correspondingPropertySymbol?.let &#123; propertySymbol -&gt;</span><br><span class="line">                <span class="keyword">if</span> (!fn.hasAnnotation(DescriptorUtils.JVM_NAME)) &#123;</span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> propertyName</span> = propertySymbol.owner.name.identifier</span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> name</span> = <span class="keyword">if</span> (fn.isGetter) &#123;</span><br><span class="line">                        JvmAbi.getterName(propertyName)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        JvmAbi.setterName(propertyName)</span><br><span class="line">                    &#125;</span><br><span class="line">                    fn.annotations += jvmNameAnnotation(name)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> valueParametersMapping</span> = explicitParameters</span><br><span class="line">                .zip(fn.explicitParameters)</span><br><span class="line">                .toMap()</span><br><span class="line"></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> currentParams</span> = fn.valueParameters.size</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> realParams</span> = currentParams - fn.contextReceiverParametersCount</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $composer</span></span><br><span class="line">            <span class="comment">// val COMPOSER_PARAMETER = Name.identifier("\$composer")</span></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> composerParam</span> = fn.addValueParameter &#123;</span><br><span class="line">                name = KtxNameConventions.COMPOSER_PARAMETER</span><br><span class="line">                type = composerType.makeNullable()</span><br><span class="line">                origin = IrDeclarationOrigin.DEFINED</span><br><span class="line">                isAssignable = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $changed[n]</span></span><br><span class="line">            <span class="comment">// val CHANGED_PARAMETER = Name.identifier("\$changed")</span></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> changed</span> = KtxNameConventions.CHANGED_PARAMETER.identifier</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until changedParamCount(realParams, fn.thisParamCount)) &#123;</span><br><span class="line">                fn.addValueParameter(</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) changed <span class="keyword">else</span> <span class="string">"$changed$i"</span>,</span><br><span class="line">                    context.irBuiltIns.intType</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $default[n]</span></span><br><span class="line">            <span class="keyword">if</span> (oldFn.requiresDefaultParameter()) &#123;</span><br><span class="line">                <span class="variable"><span class="keyword">val</span> defaults</span> = KtxNameConventions.DEFAULT_PARAMETER.identifier</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until defaultParamCount(currentParams)) &#123;</span><br><span class="line">                    fn.addValueParameter(</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span>) defaults <span class="keyword">else</span> <span class="string">"$defaults$i"</span>,</span><br><span class="line">                        context.irBuiltIns.intType,</span><br><span class="line">                        IrDeclarationOrigin.MASK_FOR_DEFAULT_FUNCTION</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inlineLambdaInfo.scan(fn)</span><br><span class="line"></span><br><span class="line">            fn.transformChildrenVoid(<span class="keyword">object</span> : IrElementTransformerVoid() &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还有很重要的一步是将 Slot Table 数据转化成可以渲染的 LayoutNode，将需要进行的变更进行 <code>record</code> 记录，此处仅仅是记录变更的操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">ComposerImpl</span></span>(</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * An adapter that applies changes to the tree using the Applier abstraction.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="variable"><span class="keyword">val</span> applier</span>: Applier<span class="type">&lt;*&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Parent of this composition; a [Recomposer] for root-level compositions.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> parentContext</span>: CompositionContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The slot table to use to store composition data</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> slotTable</span>: SlotTable,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> abandonSet</span>: MutableSet<span class="type">&lt;RememberObserver&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> changes</span>: MutableList<span class="type">&lt;Change&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> lateChanges</span>: MutableList<span class="type">&lt;Change&gt;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The composition that owns this composer</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="variable"><span class="keyword">val</span> composition</span>: ControlledComposition</span><br><span class="line">) : Composer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertMovableContentGuarded</span><span class="params">(</span><br><span class="line">        references: <span class="typename">List&lt;Pair&lt;MovableContentStateReference, MovableContentStateReference?&gt;&gt;</span></span><br><span class="line">    )</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">positionToParentOf</span><span class="params">(slots: <span class="typename">SlotWriter, applier: Applier&lt;Any?&gt;, index: Int</span>)</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">currentNodeIndex</span><span class="params">(slots: <span class="typename">SlotWriter</span>)</span>: Int &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">positionToInsert</span><span class="params">(slots: <span class="typename">SlotWriter, anchor: Anchor, applier: Applier&lt;Any?&gt;</span>)</span>: Int &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        withChanges(lateChanges) &#123;</span><br><span class="line">            record(resetSlotsInstance)</span><br><span class="line">            references.fastForEach &#123; (to, from) -&gt;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> anchor</span> = to.anchor</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> location</span> = to.slotTable.anchorIndex(anchor)</span><br><span class="line">            <span class="variable"><span class="keyword">var</span> effectiveNodeIndex</span> = <span class="number">0</span></span><br><span class="line">            realizeUps()</span><br><span class="line">            <span class="comment">// Insert content at the anchor point</span></span><br><span class="line">            record &#123; applier, slots, _ -&gt;</span><br><span class="line">                @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">                applier <span class="keyword">as</span> Applier<span class="type">&lt;Any?&gt;</span></span><br><span class="line">                effectiveNodeIndex = positionToInsert(slots, anchor, applier)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (from == <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                record &#123; applier, slots, rememberManager -&gt; ... &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                record &#123; applier, slots, rememberManager -&gt; ... &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            record &#123; applier, slots, _ -&gt;</span><br><span class="line">                @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">                applier <span class="keyword">as</span> Applier<span class="type">&lt;Any?&gt;</span></span><br><span class="line">                positionToParentOf(slots, applier, <span class="number">0</span>)</span><br><span class="line">                slots.endGroup()</span><br><span class="line">            &#125;</span><br><span class="line">            writersReaderDelta = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，通过 <code>applyChangesInLocked</code> 将 changes 操作执行最终形成 LayoutNode Tree。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">CompositionImpl</span></span>(</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The parent composition from [rememberCompositionContext], for sub-compositions, or the an</span><br><span class="line">     * instance of [Recomposer] for root compositions.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> parent</span>: CompositionContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The applier to use to update the tree managed by the composition.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> applier</span>: Applier<span class="type">&lt;*&gt;</span>,</span><br><span class="line"></span><br><span class="line">    recomposeContext: CoroutineContext? = <span class="literal">null</span></span><br><span class="line">) : ControlledComposition &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyChangesInLocked</span><span class="params">(changes: <span class="typename">MutableList&lt;Change&gt;</span>)</span> &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> manager</span> = RememberEventDispatcher(abandonSet)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (changes.isEmpty()) <span class="keyword">return</span></span><br><span class="line">            trace(<span class="string">"Compose:applyChanges"</span>) &#123;</span><br><span class="line">                applier.onBeginChanges()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Apply all changes</span></span><br><span class="line">                slotTable.write &#123; slots -&gt;</span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> applier</span> = applier</span><br><span class="line">                    changes.fastForEach &#123; change -&gt;</span><br><span class="line">                        change(applier, slots, manager)</span><br><span class="line">                    &#125;</span><br><span class="line">                    changes.clear()</span><br><span class="line">                &#125;</span><br><span class="line">                applier.onEndChanges()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Side effects run after lifecycle observers so that any remembered objects</span></span><br><span class="line">            <span class="comment">// that implement RememberObserver receive onRemembered before a side effect</span></span><br><span class="line">            <span class="comment">// that captured it and operates on it can run.</span></span><br><span class="line">            manager.dispatchRememberObservers()</span><br><span class="line">            manager.dispatchSideEffects()</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Only dispatch abandons if we do not have any late changes. The instances in the</span></span><br><span class="line">            <span class="comment">// abandon set can be remembered in the late changes.</span></span><br><span class="line">            <span class="keyword">if</span> (this.lateChanges.isEmpty())</span><br><span class="line">                manager.dispatchAbandons()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个过程中，通过 <code>RememberEventDispatcher</code> 回调所有的 <code>Effect</code> 执行。这也就是我们写代码时 Effect 的调用时机。</p>
<h1 id="1-3-AndroidComposeView-与-LayoutNode-渲染树（Layout-→-Drawing-流程）"><a href="#1-3-AndroidComposeView-与-LayoutNode-渲染树（Layout-→-Drawing-流程）" class="headerlink" title="1.3 AndroidComposeView 与 LayoutNode 渲染树（Layout → Drawing 流程）"></a>1.3 AndroidComposeView 与 LayoutNode 渲染树（Layout → Drawing 流程）</h1><p>前面我们了解到，通过解析 @Composable 函数，生成了一个可以真正被渲染的渲染树，那么后续就是如果将渲染树渲染到屏幕上。这里还是先看整理的流程图：</p>
<p><img src="/images/compose-layout-drawing.png" alt="compose-layout-drawing.png"></p>
<p>类比 Android 的经验，虽说 Compose 框架本身的机制是一套独立的渲染流程，但跑在 Android 上还是无法避免与原生 View 的体系有些桥接的过程。通过第一部分 Compose 初始化过程我们知道 Compose 最终绘制的承载 View 是 AndroidComposeView，所以我们的突破口依然还是 View 的 <code>onMeasure</code> <code>onLayout</code> 和 <code>dispatchDraw</code> 生命周期。其实 Compose 的 Layout 和 Draw 过程相比 Composition 过程算是简单很多了，同样的有 Measure 、Layout、Draw 的流程，不过官方文档中似乎一直没有提及 Measure 的过程，所以以官方的归类 Compose 的 Layout 过程是横跨了AndroidComposeView 的<code>onMeasure</code> <code>onLayout</code> 和 <code>dispatchDraw</code> 三个生命周期。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">AndroidComposeView</span></span>(context: Context) :</span><br><span class="line">    ViewGroup(context), Owner, ViewRootForTest, PositionCalculator, DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="typename">Int, heightMeasureSpec: Int</span>)</span> &#123;</span></span><br><span class="line">        trace(<span class="string">"AndroidOwner:onMeasure"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAttachedToWindow) &#123;</span><br><span class="line">                invalidateLayoutNodeMeasurement(root)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> (minWidth, maxWidth)</span> = convertMeasureSpec(widthMeasureSpec)</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> (minHeight, maxHeight)</span> = convertMeasureSpec(heightMeasureSpec)</span><br><span class="line"></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> constraints</span> = Constraints(minWidth, maxWidth, minHeight, maxHeight)</span><br><span class="line">            <span class="keyword">if</span> (onMeasureConstraints == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// first onMeasure after last onLayout</span></span><br><span class="line">                onMeasureConstraints = constraints</span><br><span class="line">                wasMeasuredWithMultipleConstraints = <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onMeasureConstraints != constraints) &#123;</span><br><span class="line">                <span class="comment">// we were remeasured twice with different constraints after last onLayout</span></span><br><span class="line">                wasMeasuredWithMultipleConstraints = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            measureAndLayoutDelegate.updateRootConstraints(constraints)</span><br><span class="line">            measureAndLayoutDelegate.measureOnly()</span><br><span class="line">            setMeasuredDimension(root.width, root.height)</span><br><span class="line">            <span class="keyword">if</span> (_androidViewsHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                androidViewsHandler.measure(</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(root.width, MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(root.height, MeasureSpec.EXACTLY)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="typename">Boolean, l: Int, t: Int, r: Int, b: Int</span>)</span> &#123;</span></span><br><span class="line">        measureAndLayoutDelegate.measureAndLayout(resendMotionEventOnLayout)</span><br><span class="line">        onMeasureConstraints = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        updatePositionCacheAndDispatch()</span><br><span class="line">        <span class="keyword">if</span> (_androidViewsHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            androidViewsHandler.layout(<span class="number">0</span>, <span class="number">0</span>, r - l, b - t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchDraw</span><span class="params">(canvas: <span class="typename">android.graphics.Canvas</span>)</span> &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!isAttachedToWindow) &#123;</span><br><span class="line">            invalidateLayers(root)</span><br><span class="line">        &#125;</span><br><span class="line">        measureAndLayout()</span><br><span class="line"></span><br><span class="line">        isDrawingContent = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        canvasHolder.drawInto(canvas) &#123; root.draw(this) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dirtyLayers.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until dirtyLayers.size) &#123;</span><br><span class="line">                <span class="variable"><span class="keyword">val</span> layer</span> = dirtyLayers[i]</span><br><span class="line">                layer.updateDisplayList()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ViewLayer.shouldUseDispatchDraw) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="variable"><span class="keyword">val</span> saveCount</span> = canvas.save()</span><br><span class="line">            canvas.clipRect(<span class="number">0</span>f, <span class="number">0</span>f, <span class="number">0</span>f, <span class="number">0</span>f)</span><br><span class="line"></span><br><span class="line">            super.dispatchDraw(canvas)</span><br><span class="line">            canvas.restoreToCount(saveCount)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirtyLayers.clear()</span><br><span class="line">        isDrawingContent = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (postponedDirtyLayers != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> postponed</span> = postponedDirtyLayers!!</span><br><span class="line">            dirtyLayers.addAll(postponed)</span><br><span class="line">            postponed.clear()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道大家有没有注意到在 AndroidComposeView 的生命周期中，有出现 <code>AndroidViewsHandler</code> 在 <code>onMeasure</code> 和 <code>onLayout</code> 中的调用，其实看源码可以发现，这就是 @Composable AndroidView 与 Compose UI 混用时的调用。同样的，AndroidView 也会在 Composition 的过程中被解析成 LayoutNode，不过原生 View 的 Measure 和 Layout 还是需要依靠 View 的基础进行的，而到的需要 draw 时，因为 LayoutNode 也同样适用了 Android Canvas，所以 draw 的过程是被当作普通节点来处理的。</p>
<h1 id="1-4-核心类关系图"><a href="#1-4-核心类关系图" class="headerlink" title="1.4 核心类关系图"></a>1.4 核心类关系图</h1><p>以上我们了解了 Compose 的渲染流程，为了对 Compose 核心类之间的关系有个更全面的了解，这里简单画了一下类图。</p>
<p><img src="/images/compose-class.png" alt="compose-class.png"></p>
<p>这里其实可以看出在整个渲染过程中有两个核心的圈子，一个是以 ComposeView 为容器的 Composition 环境（包含初始化、解析 @Composable 组件）；另一个是以 AndroidComposeView 为容器的渲染机制（底层绘制原理和应用层的 UI 组件）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，我们再来看看开头我们试图解答的几个问题，是否都有了答案：</p>
<h3 id="作为一种新的-UI-框架它是如何将-Compose-UI-渲染到屏幕上的？"><a href="#作为一种新的-UI-框架它是如何将-Compose-UI-渲染到屏幕上的？" class="headerlink" title="作为一种新的 UI 框架它是如何将 Compose UI 渲染到屏幕上的？"></a>作为一种新的 UI 框架它是如何将 Compose UI 渲染到屏幕上的？</h3><p>简单回顾下以上的所有过程，可以用下图总结：</p>
<p><img src="/images/compose-full-phases.png" alt="compose-full-phases"></p>
<p>除了上面我们分析到的与 Android View 生命周期相关的部分外，还有和帧信号带来的 Recompose 过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@ExperimentalComposeUiApi</span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">createLifecycleAwareWindowRecomposer</span><span class="params">(</span><br><span class="line">    coroutineContext: <span class="typename">CoroutineContext</span> = EmptyCoroutineContext,</span><br><span class="line">    lifecycle: <span class="typename">Lifecycle?</span> = null</span><br><span class="line">)</span>: Recomposer &#123;</span></span><br><span class="line">    <span class="comment">// Only access AndroidUiDispatcher.CurrentThread if we would use an element from it,</span></span><br><span class="line">    <span class="comment">// otherwise prevent lazy initialization.</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> baseContext</span> = <span class="keyword">if</span> (coroutineContext[ContinuationInterceptor] == <span class="literal">null</span> ||</span><br><span class="line">        coroutineContext[MonotonicFrameClock] == <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        AndroidUiDispatcher.CurrentThread + coroutineContext</span><br><span class="line">    &#125; <span class="keyword">else</span> coroutineContext</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> recomposer</span> = Recomposer(contextWithClockAndMotionScale)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> runRecomposeScope</span> = CoroutineScope(contextWithClockAndMotionScale)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> viewTreeLifecycle</span> = checkNotNull(lifecycle ?: ViewTreeLifecycleOwner.<span class="keyword">get</span>(this)?.lifecycle) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addOnAttachStateChangeListener(</span><br><span class="line">        <span class="keyword">object</span> : View.OnAttachStateChangeListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="typename">View</span>)</span> &#123;&#125;</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="typename">View</span>)</span> &#123;</span></span><br><span class="line">                removeOnAttachStateChangeListener(this)</span><br><span class="line">                recomposer.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    viewTreeLifecycle.addObserver(</span><br><span class="line">        <span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span><br><span class="line">                lifecycleOwner: <span class="typename">LifecycleOwner,</span><br><span class="line">                event: Lifecycle.Event</span></span><br><span class="line">            )</span> &#123;</span></span><br><span class="line">                <span class="variable"><span class="keyword">val</span> self</span> = this</span><br><span class="line">                <span class="keyword">when</span> (event) &#123;</span><br><span class="line">                    Lifecycle.Event.ON_CREATE -&gt; &#123;</span><br><span class="line">                        <span class="comment">// Undispatched launch since we've configured this scope</span></span><br><span class="line">                        <span class="comment">// to be on the UI thread</span></span><br><span class="line">                        runRecomposeScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">                            <span class="variable"><span class="keyword">var</span> durationScaleJob</span>: Job? = <span class="literal">null</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                durationScaleJob = systemDurationScaleSettingConsumer?.let &#123;</span><br><span class="line">                                    <span class="variable"><span class="keyword">val</span> durationScaleStateFlow</span> = getAnimationScaleFlowFor(</span><br><span class="line">                                        context.applicationContext</span><br><span class="line">                                    )</span><br><span class="line">                                    it.scaleFactor = durationScaleStateFlow.value</span><br><span class="line">                                    launch &#123;</span><br><span class="line">                                        durationScaleStateFlow.collect &#123; scaleFactor -&gt;</span><br><span class="line">                                            it.scaleFactor = scaleFactor</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                recomposer.runRecomposeAndApplyChanges()</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                ...</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Lifecycle.Event.ON_START -&gt; pausableClock?.resume()</span><br><span class="line">                    Lifecycle.Event.ON_STOP -&gt; pausableClock?.pause()</span><br><span class="line">                    Lifecycle.Event.ON_DESTROY -&gt; &#123; recomposer.cancel() &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> recomposer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recomposer</span></span>(</span><br><span class="line">    effectCoroutineContext: CoroutineContext</span><br><span class="line">) : CompositionContext() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> shouldKeepRecomposing</span>: <span class="typename">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = synchronized(stateLock) &#123; !isClosed &#125; ||</span><br><span class="line">        effectJob.children.any &#123; it.isActive &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">runRecomposeAndApplyChanges</span><span class="params">()</span> = recompositionRunner &#123; parentFrameClock -&gt;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> toRecompose</span> = mutableListOf<span class="type">&lt;ControlledComposition&gt;</span>()</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> toInsert</span> = mutableListOf<span class="type">&lt;MovableContentStateReference&gt;</span>()</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> toApply</span> = mutableListOf<span class="type">&lt;ControlledComposition&gt;</span>()</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> toLateApply</span> = mutableSetOf<span class="type">&lt;ControlledComposition&gt;</span>()</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> toComplete</span> = mutableSetOf<span class="type">&lt;ControlledComposition&gt;</span>()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">clearRecompositionState</span><span class="params">()</span> &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fillToInsert</span><span class="params">()</span> &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (shouldKeepRecomposing) &#123;</span><br><span class="line">            awaitWorkAvailable()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't await a new frame if we don't have frame-scoped work</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                synchronized(stateLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!hasFrameWorkLocked) &#123;</span><br><span class="line">                        recordComposerModificationsLocked()</span><br><span class="line">                        !hasFrameWorkLocked</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 与下一帧对齐任务以合并更改。</span></span><br><span class="line">            parentFrameClock.withFrameNanos &#123; frameTime -&gt;</span><br><span class="line">                <span class="comment">// Dispatch MonotonicFrameClock frames first; this may produce new</span></span><br><span class="line">                <span class="comment">// composer invalidations that we must handle during the same frame.</span></span><br><span class="line">                <span class="keyword">if</span> (broadcastFrameClock.hasAwaiters) &#123;</span><br><span class="line">                    trace(<span class="string">"Recomposer:animation"</span>) &#123;</span><br><span class="line">                        <span class="comment">// Propagate the frame time to anyone who is awaiting from the</span></span><br><span class="line">                        <span class="comment">// recomposer clock.</span></span><br><span class="line">                        broadcastFrameClock.sendFrame(frameTime)</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Ensure any global changes are observed</span></span><br><span class="line">                        Snapshot.sendApplyNotifications()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                trace(<span class="string">"Recomposer:recompose"</span>) &#123;</span><br><span class="line">                    <span class="comment">// Drain any composer invalidations from snapshot changes and record</span></span><br><span class="line">                    <span class="comment">// composers to work on</span></span><br><span class="line">                    synchronized(stateLock) &#123;</span><br><span class="line">                        recordComposerModificationsLocked()</span><br><span class="line"></span><br><span class="line">                        compositionInvalidations.fastForEach &#123; toRecompose += it &#125;</span><br><span class="line">                        compositionInvalidations.clear()</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Perform recomposition for any invalidated composers</span></span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> modifiedValues</span> = IdentityArraySet<span class="type">&lt;Any&gt;</span>()</span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> alreadyComposed</span> = IdentityArraySet<span class="type">&lt;ControlledComposition&gt;</span>()</span><br><span class="line">                    <span class="keyword">while</span> (toRecompose.isNotEmpty() || toInsert.isNotEmpty()) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                            toRecompose.fastForEach &#123; composition -&gt;</span><br><span class="line">                                alreadyComposed.add(composition)</span><br><span class="line">                                performRecompose(composition, modifiedValues)?.let &#123;</span><br><span class="line">                                    toApply += it</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ...</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Find any trailing recompositions that need to be composed because</span></span><br><span class="line">                        <span class="comment">// of a value change by a composition. This can happen, for example, if</span></span><br><span class="line">                        <span class="comment">// a CompositionLocal changes in a parent and was read in a child</span></span><br><span class="line">                        <span class="comment">// composition that was otherwise valid.</span></span><br><span class="line">                        <span class="keyword">if</span> (modifiedValues.isNotEmpty()) &#123;</span><br><span class="line">                            synchronized(stateLock) &#123;</span><br><span class="line">                                knownCompositions.fastForEach &#123; value -&gt;</span><br><span class="line">                                    <span class="keyword">if</span> (</span><br><span class="line">                                        value !<span class="keyword">in</span> alreadyComposed &amp;&amp;</span><br><span class="line">                                        value.observesAnyOf(modifiedValues)</span><br><span class="line">                                    ) &#123;</span><br><span class="line">                                        toRecompose += value</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (toRecompose.isEmpty()) &#123;</span><br><span class="line">                            ...</span><br><span class="line">                                fillToInsert()</span><br><span class="line">                                <span class="keyword">while</span> (toInsert.isNotEmpty()) &#123;</span><br><span class="line">                                    toLateApply += performInsertValues(toInsert, modifiedValues)</span><br><span class="line">                                    fillToInsert()</span><br><span class="line">                                &#125;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (toApply.isNotEmpty()) &#123;</span><br><span class="line">                        changeCount++</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Perform apply changes</span></span><br><span class="line">                        ...</span><br><span class="line">                            toComplete += toApply</span><br><span class="line">                            toApply.fastForEach &#123; composition -&gt;</span><br><span class="line">                                composition.applyChanges()</span><br><span class="line">                            &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (toLateApply.isNotEmpty()) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                            toComplete += toLateApply</span><br><span class="line">                            toLateApply.forEach &#123; composition -&gt;</span><br><span class="line">                                composition.applyLateChanges()</span><br><span class="line">                            &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (toComplete.isNotEmpty()) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                            toComplete.forEach &#123; composition -&gt;</span><br><span class="line">                                composition.changesApplied()</span><br><span class="line">                            &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    synchronized(stateLock) &#123;</span><br><span class="line">                        deriveStateLocked()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            discardUnusedValues()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平常在写代码时，经常用到-LaunchedEffect、SideEffect-是怎么样生效的？"><a href="#平常在写代码时，经常用到-LaunchedEffect、SideEffect-是怎么样生效的？" class="headerlink" title="平常在写代码时，经常用到 LaunchedEffect、SideEffect 是怎么样生效的？"></a><strong>平常在写代码时，经常用到 LaunchedEffect、SideEffect 是怎么样生效的？</strong></h3><p>首先我们来看比较简单的 SideEffect，可以看到将 SideEffect 函数记录在 RememberEventDispatcher 中，在 1.2 的部分我们知道，解析成渲染树后，通过 <code>RememberEventDispatcher</code> 回调了 SideEffect 执行，所以 SideEffect 是每次 (Re)Compose 过程中都会被执行，且是在主线程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">@NonRestartableComposable</span><br><span class="line">@OptIn(InternalComposeApi::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SideEffect</span><span class="params">(</span><br><span class="line">    effect: <span class="typename">(</span>)</span> -&gt; Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    currentComposer.recordSideEffect(effect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">ComposerImpl</span></span>(...): Composer &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">recordSideEffect</span><span class="params">(effect: <span class="typename">(</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">        record &#123; _, _, rememberManager -&gt; rememberManager.sideEffect(effect) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RememberEventDispatcher</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> abandoning</span>: MutableSet<span class="type">&lt;RememberObserver&gt;</span></span><br><span class="line">    ) : RememberManager &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> sideEffects</span> = mutableListOf<span class="type">&lt;() -&gt;</span> <span class="typename">Unit</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sideEffect</span><span class="params">(effect: <span class="typename">(</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">            sideEffects += effect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看相对复杂一些的 LaunchedEffect，同样的还是最终被记录在 RememberEventDispatcher 中，与 SideEffect 不同的是，LaunchedEffect 执行一次后会被移除，且是通过协程的方式启动。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">@NonRestartableComposable</span><br><span class="line">@OptIn(InternalComposeApi::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LaunchedEffect</span><span class="params">(</span><br><span class="line">    key1: <span class="typename">Any?,</span><br><span class="line">    block: suspend CoroutineScope.(</span>)</span> -&gt; Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> applyContext</span> = currentComposer.applyCoroutineContext</span><br><span class="line">    remember(key1) &#123; LaunchedEffectImpl(applyContext, block) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">LaunchedEffectImpl</span></span>(</span><br><span class="line">    parentCoroutineContext: CoroutineContext,</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> task</span>: suspend CoroutineScope.() -&gt; <span class="typename">Unit</span></span><br><span class="line">) : RememberObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> scope</span> = CoroutineScope(parentCoroutineContext)</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> job</span>: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRemembered</span><span class="params">()</span> &#123;</span></span><br><span class="line">        job?.cancel(<span class="string">"Old job was still running!"</span>)</span><br><span class="line">        job = scope.launch(block = task)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onForgotten</span><span class="params">()</span> &#123;</span></span><br><span class="line">        job?.cancel()</span><br><span class="line">        job = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAbandoned</span><span class="params">()</span> &#123;</span></span><br><span class="line">        job?.cancel()</span><br><span class="line">        job = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ComposeCompilerApi</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Composer.<span class="title">cache</span><span class="params">(invalid: <span class="typename">Boolean, block: @DisallowComposableCalls (</span>)</span> -&gt; T): T &#123;</span></span><br><span class="line">    @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">    <span class="keyword">return</span> rememberedValue().let &#123;</span><br><span class="line">        <span class="keyword">if</span> (invalid || it === Composer.Empty) &#123;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> value</span> = block()</span><br><span class="line">            updateRememberedValue(value)</span><br><span class="line">            value</span><br><span class="line">        &#125; <span class="keyword">else</span> it</span><br><span class="line">    &#125; <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">ComposerImpl</span></span>(...): Composer &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @PublishedApi</span><br><span class="line">    @OptIn(InternalComposeApi::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">    internal <span class="function"><span class="keyword">fun</span> <span class="title">updateValue</span><span class="params">(value: <span class="typename">Any?</span>)</span> &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (inserting) &#123;</span><br><span class="line">            writer.update(value)</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">is</span> RememberObserver) &#123;</span><br><span class="line">                record &#123; _, _, rememberManager -&gt; rememberManager.remembering(value) &#125;</span><br><span class="line">                abandonSet.add(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> groupSlotIndex</span> = reader.groupSlotIndex - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">is</span> RememberObserver) &#123;</span><br><span class="line">                abandonSet.add(value)</span><br><span class="line">            &#125;</span><br><span class="line">            recordSlotTableOperation(forParent = <span class="literal">true</span>) &#123; _, slots, rememberManager -&gt;</span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">is</span> RememberObserver) &#123;</span><br><span class="line">                    rememberManager.remembering(value)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">when</span> (<span class="variable"><span class="keyword">val</span> previous</span> = slots.<span class="keyword">set</span>(groupSlotIndex, value)) &#123;</span><br><span class="line">                    <span class="keyword">is</span> RememberObserver -&gt;</span><br><span class="line">                        rememberManager.forgetting(previous)</span><br><span class="line">                    <span class="keyword">is</span> RecomposeScopeImpl -&gt; &#123;</span><br><span class="line">                        <span class="variable"><span class="keyword">val</span> composition</span> = previous.composition</span><br><span class="line">                        <span class="keyword">if</span> (composition != <span class="literal">null</span>) &#123;</span><br><span class="line">                            previous.release()</span><br><span class="line">                            composition.pendingInvalidScopes = <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">rememberedValue</span><span class="params">()</span>: Any? = <span class="title">nextSlot</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateRememberedValue</span><span class="params">(value: <span class="typename">Any?</span>)</span> = <span class="title">updateValue</span><span class="params">(value)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RememberEventDispatcher</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> abandoning</span>: MutableSet<span class="type">&lt;RememberObserver&gt;</span></span><br><span class="line">    ) : RememberManager &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> remembering</span> = mutableListOf<span class="type">&lt;RememberObserver&gt;</span>()</span><br><span class="line">        <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> forgetting</span> = mutableListOf<span class="type">&lt;RememberObserver&gt;</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remembering</span><span class="params">(instance: <span class="typename">RememberObserver</span>)</span> &#123;</span></span><br><span class="line">            forgetting.lastIndexOf(instance).let &#123; index -&gt;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    forgetting.removeAt(index)</span><br><span class="line">                    abandoning.remove(instance)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    remembering.add(instance)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">forgetting</span><span class="params">(instance: <span class="typename">RememberObserver</span>)</span> &#123;</span></span><br><span class="line">            remembering.lastIndexOf(instance).let &#123; index -&gt;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    remembering.removeAt(index)</span><br><span class="line">                    abandoning.remove(instance)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    forgetting.add(instance)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompositionLocal-通过-Composable-函数隐式向下传递数据，它又是怎么样发挥作用的？"><a href="#CompositionLocal-通过-Composable-函数隐式向下传递数据，它又是怎么样发挥作用的？" class="headerlink" title="CompositionLocal 通过 @Composable 函数隐式向下传递数据，它又是怎么样发挥作用的？"></a>CompositionLocal 通过 @Composable 函数隐式向下传递数据，它又是怎么样发挥作用的？</h3><p>使用 CompositionLocal 的方式是通过 <code>CompositionLocalProvider</code> 向下传递数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">@OptIn(InternalComposeApi::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CompositionLocalProvider</span><span class="params">(vararg values: <span class="typename">ProvidedValue&lt;*&gt;, content: @Composable (</span>)</span> -&gt; Unit) &#123;</span></span><br><span class="line">    currentComposer.startProviders(values)</span><br><span class="line">    content()</span><br><span class="line">    currentComposer.endProviders()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 1.1 Composition 过程，我们知道 Composition 会将 @Composable 函数转化为基于代码位置的存储（Positional Memoization）数据，记录在 SlotTable 中。而其中记录的不只是 UI 的位置或者 UI 的状态，也包含一些值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">ComposerImpl</span></span>(</span><br><span class="line">    ...</span><br><span class="line">) : Composer &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">currentCompositionLocalScope</span><span class="params">(group: <span class="typename">Int?</span> = null)</span>: CompositionLocalMap &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (group == <span class="literal">null</span>)</span><br><span class="line">            providerCache?.let &#123; <span class="keyword">return</span> it &#125;</span><br><span class="line">        <span class="keyword">if</span> (inserting &amp;&amp; writerHasAProvider) &#123;</span><br><span class="line">            <span class="variable"><span class="keyword">var</span> current</span> = writer.parent</span><br><span class="line">            <span class="keyword">while</span> (current &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (writer.groupKey(current) == compositionLocalMapKey &amp;&amp;</span><br><span class="line">                    writer.groupObjectKey(current) == compositionLocalMap</span><br><span class="line">                ) &#123;</span><br><span class="line">                    @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> providers</span> = writer.groupAux(current) <span class="keyword">as</span> CompositionLocalMap</span><br><span class="line">                    providerCache = providers</span><br><span class="line">                    <span class="keyword">return</span> providers</span><br><span class="line">                &#125;</span><br><span class="line">                current = writer.parent(current)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        providerCache = parentProvider</span><br><span class="line">        <span class="keyword">return</span> parentProvider</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @InternalComposeApi</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startProviders</span><span class="params">(values: <span class="typename">Array&lt;out ProvidedValue&lt;*&gt;&gt;</span>)</span> &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> parentScope</span> = currentCompositionLocalScope()</span><br><span class="line">        startGroup(providerKey, provider)</span><br><span class="line">        <span class="comment">// The group is needed here because compositionLocalMapOf() might change the number or</span></span><br><span class="line">        <span class="comment">// kind of slots consumed depending on the content of values to remember, for example, the</span></span><br><span class="line">        <span class="comment">// value holders used last time.</span></span><br><span class="line">        startGroup(providerValuesKey, providerValues)</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> currentProviders</span> = invokeComposableForResult(this) &#123;</span><br><span class="line">            compositionLocalMapOf(values, parentScope)</span><br><span class="line">        &#125;</span><br><span class="line">        endGroup()</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> providers</span>: CompositionLocalMap</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> invalid</span>: <span class="typename">Boolean</span></span><br><span class="line">        <span class="keyword">if</span> (inserting) &#123;</span><br><span class="line">            providers = updateProviderMapGroup(parentScope, currentProviders)</span><br><span class="line">            invalid = <span class="literal">false</span></span><br><span class="line">            writerHasAProvider = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> oldScope</span> = reader.groupGet(<span class="number">0</span>) <span class="keyword">as</span> CompositionLocalMap</span><br><span class="line"></span><br><span class="line">            @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> oldValues</span> = reader.groupGet(<span class="number">1</span>) <span class="keyword">as</span> CompositionLocalMap</span><br><span class="line"></span><br><span class="line">            <span class="comment">// skipping is true iff parentScope has not changed.</span></span><br><span class="line">            <span class="keyword">if</span> (!skipping || oldValues != currentProviders) &#123;</span><br><span class="line">                providers = updateProviderMapGroup(parentScope, currentProviders)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                invalid = providers != oldScope</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Nothing has changed</span></span><br><span class="line">                skipGroup()</span><br><span class="line">                providers = oldScope</span><br><span class="line">                invalid = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invalid &amp;&amp; !inserting) &#123;</span><br><span class="line">            providerUpdates[reader.currentGroup] = providers</span><br><span class="line">        &#125;</span><br><span class="line">        providersInvalidStack.push(providersInvalid.asInt())</span><br><span class="line">        providersInvalid = invalid</span><br><span class="line">        providerCache = providers</span><br><span class="line">        start(compositionLocalMapKey, compositionLocalMap, <span class="literal">false</span>, providers)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @InternalComposeApi</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">endProviders</span><span class="params">()</span> &#123;</span></span><br><span class="line">        endGroup()</span><br><span class="line">        endGroup()</span><br><span class="line">        providersInvalid = providersInvalidStack.pop().asBool()</span><br><span class="line">        providerCache = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上通过 Compositon 的过程将 <code>CompositionLocalProvider</code> 提供的数据记录在 slotTable 中，而在使用时，则通过调用 CompositionLocal 获取当前值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Stable</span><br><span class="line">sealed <span class="class"><span class="keyword">class</span> <span class="title">CompositionLocal</span>&lt;<span class="type">T</span>&gt; <span class="title">constructor</span></span>(defaultFactory: () -&gt; T) &#123;</span><br><span class="line">    @Suppress(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">    internal <span class="variable"><span class="keyword">val</span> defaultValueHolder</span> = LazyValueHolder(defaultFactory)</span><br><span class="line"></span><br><span class="line">    @Composable</span><br><span class="line">    internal abstract <span class="function"><span class="keyword">fun</span> <span class="title">provided</span><span class="params">(value: <span class="typename">T</span>)</span>: State<span class="type">&lt;T&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Return the value provided by the nearest [CompositionLocalProvider] component that invokes, directly or</span><br><span class="line">     * indirectly, the composable function that uses this property.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@sample</span> androidx.compose.runtime.samples.consumeCompositionLocal</span><br><span class="line">     */</span></span><br><span class="line">    @OptIn(InternalComposeApi::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="variable"><span class="keyword">val</span> current</span>: T</span><br><span class="line">        @ReadOnlyComposable</span><br><span class="line">        @Composable</span><br><span class="line">        <span class="keyword">get</span>() = currentComposer.consume(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">internal class ComposerImpl(</span><br><span class="line">    ...</span><br><span class="line">) : Composer &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @InternalComposeApi</span><br><span class="line">    override fun &lt;T&gt; consume(key: CompositionLocal&lt;T&gt;): T =</span><br><span class="line">        resolveCompositionLocal(key, currentCompositionLocalScope())</span><br><span class="line"></span><br><span class="line">    private fun currentCompositionLocalScope(group: Int? = null): CompositionLocalMap &#123;</span><br><span class="line">        if (group == null)</span><br><span class="line">            providerCache?.let &#123; return it &#125;</span><br><span class="line">        ...</span><br><span class="line">        if (reader.size &gt; 0) &#123;</span><br><span class="line">            var current = group ?: reader.parent</span><br><span class="line">            while (current &gt; 0) &#123;</span><br><span class="line">                if (reader.groupKey(current) == compositionLocalMapKey &amp;&amp;</span><br><span class="line">                    reader.groupObjectKey(current) == compositionLocalMap</span><br><span class="line">                ) &#123;</span><br><span class="line">                    @Suppress("UNCHECKED_CAST")</span><br><span class="line">                    val providers = providerUpdates[current]</span><br><span class="line">                        ?: reader.groupAux(current) as CompositionLocalMap</span><br><span class="line">                    providerCache = providers</span><br><span class="line">                    return providers</span><br><span class="line">                &#125;</span><br><span class="line">                current = reader.parent(current)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        providerCache = parentProvider</span><br><span class="line">        return parentProvider</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Composable-AndroidView-是怎么和-Compose-进行组合渲染的？"><a href="#Composable-AndroidView-是怎么和-Compose-进行组合渲染的？" class="headerlink" title="@Composable AndroidView 是怎么和 Compose 进行组合渲染的？"></a><strong>@Composable AndroidView 是怎么和 Compose 进行组合渲染的？</strong></h3><p>首先我们来看 AndroidView 的实现，由此可以见，虽然是原生的 View，但在 Compose 的体系中仍然是作为你一个 Node 节点来进行逻辑渲染的，不过与其他 Compsoe Node 不同的是，AndroidView 仍然需要借助 Android 视图体系来完成测量和布局。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View&gt;</span> <span class="title">AndroidView</span><span class="params">(</span><br><span class="line">    factory: <span class="typename">(Context</span>)</span> -&gt; T,</span></span><br><span class="line">    modifier: Modifier = Modifier,</span><br><span class="line">    update: (T) -&gt; <span class="typename">Unit</span> = NoOpUpdate</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ComposeNode<span class="type">&lt;LayoutNode, UiApplier&gt;</span>(</span><br><span class="line">    factory = &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> viewFactoryHolder</span> = ViewFactoryHolder<span class="type">&lt;T&gt;</span>(context, parentReference, dispatcher)</span><br><span class="line">        viewFactoryHolder.factory = factory</span><br><span class="line">        ...</span><br><span class="line">        viewFactoryHolderRef.value = viewFactoryHolder</span><br><span class="line">        viewFactoryHolder.layoutNode</span><br><span class="line">    &#125;,</span><br><span class="line">    update = &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 1.3 的渲染过程中，查看 <code>AndroidComposeView</code> 的源码我们可以看出来在，onMeasure 和 onLayout 的过程中都有 <code>androidViewsHandler</code> 的身影参与其中，那为什么 dispatchDraw 中反而没有了 <code>androidViewsHandler</code> 影子呢，这是因为上面提到的在 Drawing 的过程中，仍然是依靠 LayoutNode 渲染树来管理的，当真正需要 draw 的时候就回通过 AndroidComposeView 调用到 AndroidViewsHandler 的 drawView 函数完成绘制。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewsHandler</span></span>(context: Context) : ViewGroup(context) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        clipChildren = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> holderToLayoutNode</span> = hashMapOf<span class="type">&lt;AndroidViewHolder, LayoutNode&gt;</span>()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> layoutNodeToHolder</span> = hashMapOf<span class="type">&lt;LayoutNode, AndroidViewHolder&gt;</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="typename">Int, heightMeasureSpec: Int</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// Layout will be handled by component nodes. However, we act like proper measurement</span></span><br><span class="line">        <span class="comment">// here in case ViewRootImpl did forceLayout().</span></span><br><span class="line">        require(MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY)</span><br><span class="line">        require(MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY)</span><br><span class="line">        setMeasuredDimension(</span><br><span class="line">            MeasureSpec.getSize(widthMeasureSpec),</span><br><span class="line">            MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// Remeasure children, such that, if ViewRootImpl did forceLayout(), the holders</span></span><br><span class="line">        <span class="comment">// will be set PFLAG_LAYOUT_REQUIRED and they will be relaid out during the next layout.</span></span><br><span class="line">        <span class="comment">// This will ensure that the need relayout flags will be cleared correctly.</span></span><br><span class="line">        holderToLayoutNode.keys.forEach &#123; it.remeasure() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="typename">Boolean, l: Int, t: Int, r: Int, b: Int</span>)</span> &#123;</span></span><br><span class="line">        <span class="comment">// Layout was already handled by component nodes, but replace here because</span></span><br><span class="line">        <span class="comment">// the View system has forced relayout on children. This method will only be called</span></span><br><span class="line">        <span class="comment">// when forceLayout is called on the Views hierarchy.</span></span><br><span class="line">        holderToLayoutNode.keys.forEach &#123; it.layout(it.left, it.top, it.right, it.bottom) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestLayout</span><span class="params">()</span> &#123;</span></span><br><span class="line">        <span class="comment">// Hack to cleanup the dirty layout flag on ourselves, such that this method continues</span></span><br><span class="line">        <span class="comment">// to be called for further children requestLayout().</span></span><br><span class="line">        cleanupLayoutState(this)</span><br><span class="line">        <span class="comment">// requestLayout() was called by a child, so we have to request remeasurement for</span></span><br><span class="line">        <span class="comment">// their corresponding layout node.</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> child</span> = getChildAt(i)</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> node</span> = holderToLayoutNode[child]</span><br><span class="line">            <span class="keyword">if</span> (child.isLayoutRequested &amp;&amp; node != <span class="literal">null</span>) &#123;</span><br><span class="line">                node.requestRemeasure()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drawView</span><span class="params">(view: <span class="typename">AndroidViewHolder, canvas: Canvas</span>)</span> &#123;</span></span><br><span class="line">        view.draw(canvas)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Compose 的渲染过程也分析完毕，在此之外，相信我们试图解答的问题也有了答案。希望以上内容能帮助大家在使用过程中对 Compose 有更深的理解，也能更加运用自如。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2020/07/17/nested_ceiling_effect/" class="next">下一篇</a></div><div style="padding:0; margin: 30px auto; width: 100%; text-align: center;"><div style="font-size: 1em; margin: 10px auto;color:#f44336;font-weight: bold"> 如果觉得本文对你有帮助，不妨请作者喝瓶养乐多<div style="padding: 0; margin: 10px auto; width: 100%; text-align: center; color:#f44336;"></div></div><button style="cursor: pointer; border: 0; outline: 0; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0; text-shadow: none; background-color: transparent; text-align: center; cursor: pointer;" id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span style="display: inline-block; width: 70px; height: 70px; color: #fff; font-weight: bold; font-style: normal; font-variant: normal; font-stretch: normal; font-size: 2.5em; text-align: center; line-height: 70px; background: #f44336; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%;">赏</span></button><div id="QR" style="display: none;"><div id="wechat" style="width: auto; max-width: 50%; float: left; margin: 20px; display: inline-block;"><img id="wechat_qr" src="/images/wechat.png" alt="WechatPay"></div><div id="alipay" style="width: auto; max-width: 50%; float: right; margin: 20px; display: inline-block;"><img id="alipay_qr" src="/images/alipay.png" alt="Alipay"></div></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "",
    productKey: "8b0c22fa1d324f8e9c45b4f8e5d5c325",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script><div class="copyright"><p>© 2015 - 2024 <a href="http://solart.cc">Oz</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-51018462-1",'auto');ga('send','pageview');</script></body></html>